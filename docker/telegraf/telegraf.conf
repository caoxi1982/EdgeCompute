# Telegraf Configuration
#
# Telegraf is entirely plugin driven. All metrics are gathered from the
# declared inputs, and sent to the declared outputs.
#
# Plugins must be declared in here to be active.
# To deactivate a plugin, comment out the name and any variables.
#
# Use 'telegraf -config telegraf.conf -test' to see what metrics a config
# file would generate.
#
# Environment variables can be used anywhere in this config file, simply surround
# them with ${}. For strings the variable must be within quotes (ie, "${STR_VAR}"),
# for numbers and booleans they should be plain (ie, ${INT_VAR}, ${BOOL_VAR})


# Global tags can be specified here in key="value" format.
[global_tags]
  # dc = "us-east-1" # will tag all metrics with dc=us-east-1
  # rack = "1a"
  ## Environment variables can be used as tags, and throughout the config file
  # user = "$USER"


# Configuration for telegraf agent
[agent]
  ## Default data collection interval for all inputs
  interval = "1000ms"
  ## Rounds collection interval to 'interval'
  ## ie, if interval="10s" then always collect on :00, :10, :20, etc.
  round_interval = true

  ## Telegraf will send metrics to outputs in batches of at most
  ## metric_batch_size metrics.
  ## This controls the size of writes that Telegraf sends to output plugins.
  metric_batch_size = 1000

  ## Maximum number of unwritten metrics per output.  Increasing this value
  ## allows for longer periods of output downtime without dropping metrics at the
  ## cost of higher maximum memory usage.
  metric_buffer_limit = 10000

  ## Collection jitter is used to jitter the collection by a random amount.
  ## Each plugin will sleep for a random time within jitter before collecting.
  ## This can be used to avoid many plugins querying things like sysfs at the
  ## same time, which can have a measurable effect on the system.
  collection_jitter = "0s"

  ## Collection offset is used to shift the collection by the given amount.
  ## This can be be used to avoid many plugins querying constraint devices
  ## at the same time by manually scheduling them in time.
  # collection_offset = "0s"

  ## Default flushing interval for all outputs. Maximum flush_interval will be
  ## flush_interval + flush_jitter
  flush_interval = "10s"
  ## Jitter the flush interval by a random amount. This is primarily to avoid
  ## large write spikes for users running a large number of telegraf instances.
  ## ie, a jitter of 5s and interval 10s means flushes will happen every 10-15s
  flush_jitter = "2s"

  ## Collected metrics are rounded to the precision specified. Precision is
  ## specified as an interval with an integer + unit (e.g. 0s, 10ms, 2us, 4s).
  ## Valid time units are "ns", "us" (or "µs"), "ms", "s".
  ##
  ## By default or when set to "0s", precision will be set to the same
  ## timestamp order as the collection interval, with the maximum being 1s:
  ##   ie, when interval = "10s", precision will be "1s"
  ##       when interval = "250ms", precision will be "1ms"
  ##
  ## Precision will NOT be used for service inputs. It is up to each individual
  ## service input to set the timestamp at the appropriate precision.
  precision = "0s"

  ## Log at debug level.
  debug = false
  ## Log only error level messages.
  # quiet = false

  ## Log target controls the destination for logs and can be one of "file",
  ## "stderr" or, on Windows, "eventlog".  When set to "file", the output file
  ## is determined by the "logfile" setting.
  logtarget = "file"

  ## Name of the file to be logged to when using the "file" logtarget.  If set to
  ## the empty string then logs are written to stderr.
  logfile = "/var/lib/influxdb2/logs/t_log.log"

  ## The logfile will be rotated after the time interval specified.  When set
  ## to 0 no time based rotation is performed.  Logs are rotated only when
  ## written to, if there is no log activity rotation may be delayed.
  # logfile_rotation_interval = "0h"

  ## The logfile will be rotated when it becomes larger than the specified
  ## size.  When set to 0 no size based rotation is performed.
  # logfile_rotation_max_size = "0MB"

  ## Maximum number of rotated archives to keep, any older logs are deleted.
  ## If set to -1, no archives are removed.
  # logfile_rotation_max_archives = 5

  ## Pick a timezone to use when logging or type 'local' for local time.
  ## Example: America/Chicago
  # log_with_timezone = ""

  ## Override default hostname, if empty use os.Hostname()
  hostname = "telegraf"
  ## If set to true, do no set the "host" tag in the telegraf agent.
  omit_hostname = false

  ## Method of translating SNMP objects. Can be "netsnmp" which
  ## translates by calling external programs snmptranslate and snmptable,
  ## or "gosmi" which translates using the built-in gosmi library.
  # snmp_translator = "netsnmp"

###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################


# Configuration for sending metrics to InfluxDB
[[outputs.influxdb_v2]]
## The full HTTP or UDP URL for your InfluxDB instance.
##
## Multiple URLs can be specified for a single cluster, only ONE of the
## urls will be written to each interval.
# urls = ["unix:///var/run/influxdb.sock"]
# urls = ["udp://127.0.0.1:8089"]
urls = ["http://influx:8086"]
## Token for authentication.
token = "U0pdAvYrUbJMPvnD8YZjkm9d8KCVHpeBEe1_LiVlQImsr98ERFRrYKge1hsZVeht_VfEAixTkgsAi6B85lax-Q=="

## Organization is the name of the organization you wish to write to.
organization = "ra"

## Destination bucket to write into.
bucket = "ISC1"



# # Publishes metrics to an AMQP broker
# [[outputs.amqp]]
#   ## Brokers to publish to.  If multiple brokers are specified a random broker
#   ## will be selected anytime a connection is established.  This can be
#   ## helpful for load balancing when not using a dedicated load balancer.
#   brokers = ["amqp://localhost:5672/influxdb"]
#
#   ## Maximum messages to send over a connection.  Once this is reached, the
#   ## connection is closed and a new connection is made.  This can be helpful for
#   ## load balancing when not using a dedicated load balancer.
#   # max_messages = 0
#
#   ## Exchange to declare and publish to.
#   exchange = "telegraf"
#
#   ## Exchange type; common types are "direct", "fanout", "topic", "header", "x-consistent-hash".
#   # exchange_type = "topic"
#
#   ## If true, exchange will be passively declared.
#   # exchange_passive = false
#
#   ## Exchange durability can be either "transient" or "durable".
#   # exchange_durability = "durable"
#
#   ## Additional exchange arguments.
#   # exchange_arguments = { }
#   # exchange_arguments = {"hash_property" = "timestamp"}
#
#   ## Authentication credentials for the PLAIN auth_method.
#   # username = ""
#   # password = ""
#
#   ## Auth method. PLAIN and EXTERNAL are supported
#   ## Using EXTERNAL requires enabling the rabbitmq_auth_mechanism_ssl plugin as
#   ## described here: https://www.rabbitmq.com/plugins.html
#   # auth_method = "PLAIN"
#
#   ## Metric tag to use as a routing key.
#   ##   ie, if this tag exists, its value will be used as the routing key
#   # routing_tag = "host"
#
#   ## Static routing key.  Used when no routing_tag is set or as a fallback
#   ## when the tag specified in routing tag is not found.
#   # routing_key = ""
#   # routing_key = "telegraf"
#
#   ## Delivery Mode controls if a published message is persistent.
#   ##   One of "transient" or "persistent".
#   # delivery_mode = "transient"
#
#   ## Static headers added to each published message.
#   # headers = { }
#   # headers = {"database" = "telegraf", "retention_policy" = "default"}
#
#   ## Connection timeout.  If not provided, will default to 5s.  0s means no
#   ## timeout (not recommended).
#   # timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## If true use batch serialization format instead of line based delimiting.
#   ## Only applies to data formats which are not line based such as JSON.
#   ## Recommended to set to true.
#   # use_batch_format = false
#
#   ## Content encoding for message payloads, can be set to "gzip" to or
#   ## "identity" to apply no encoding.
#   ##
#   ## Please note that when use_batch_format = false each amqp message contains only
#   ## a single metric, it is recommended to use compression with batch format
#   ## for best results.
#   # content_encoding = "identity"
#
#   ## Data format to output.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   # data_format = "influx"


# # Send metrics to Azure Application Insights
# [[outputs.application_insights]]
#   ## Instrumentation key of the Application Insights resource.
#   instrumentation_key = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxx"
#
#   ## Regions that require endpoint modification https://docs.microsoft.com/en-us/azure/azure-monitor/app/custom-endpoints
#   # endpoint_url = "https://dc.services.visualstudio.com/v2/track"
#
#   ## Timeout for closing (default: 5s).
#   # timeout = "5s"
#
#   ## Enable additional diagnostic logging.
#   # enable_diagnostic_logging = false
#
#   ## Context Tag Sources add Application Insights context tags to a tag value.
#   ##
#   ## For list of allowed context tag keys see:
#   ## https://github.com/microsoft/ApplicationInsights-Go/blob/master/appinsights/contracts/contexttagkeys.go
#   # [outputs.application_insights.context_tag_sources]
#   #   "ai.cloud.role" = "kubernetes_container_name"
#   #   "ai.cloud.roleInstance" = "kubernetes_pod_name"


# # Sends metrics to Azure Data Explorer
# [[outputs.azure_data_explorer]]
#   ## Azure Data Explorer cluster endpoint
#   ## ex: endpoint_url = "https://clustername.australiasoutheast.kusto.windows.net"
#   endpoint_url = ""
#
#   ## The Azure Data Explorer database that the metrics will be ingested into.
#   ## The plugin will NOT generate this database automatically, it's expected that this database already exists before ingestion.
#   ## ex: "exampledatabase"
#   database = ""
#
#   ## Timeout for Azure Data Explorer operations
#   # timeout = "20s"
#
#   ## Type of metrics grouping used when pushing to Azure Data Explorer.
#   ## Default is "TablePerMetric" for one table per different metric.
#   ## For more information, please check the plugin README.
#   # metrics_grouping_type = "TablePerMetric"
#
#   ## Name of the single table to store all the metrics (Only needed if metrics_grouping_type is "SingleTable").
#   # table_name = ""
#
#   ## Creates tables and relevant mapping if set to true(default).
#   ## Skips table and mapping creation if set to false, this is useful for running Telegraf with the lowest possible permissions i.e. table ingestor role.
#   # create_tables = true


# # Send aggregate metrics to Azure Monitor
# [[outputs.azure_monitor]]
#   ## Timeout for HTTP writes.
#   # timeout = "20s"
#
#   ## Set the namespace prefix, defaults to "Telegraf/<input-name>".
#   # namespace_prefix = "Telegraf/"
#
#   ## Azure Monitor doesn't have a string value type, so convert string
#   ## fields to dimensions (a.k.a. tags) if enabled. Azure Monitor allows
#   ## a maximum of 10 dimensions so Telegraf will only send the first 10
#   ## alphanumeric dimensions.
#   # strings_as_dimensions = false
#
#   ## Both region and resource_id must be set or be available via the
#   ## Instance Metadata service on Azure Virtual Machines.
#   #
#   ## Azure Region to publish metrics against.
#   ##   ex: region = "southcentralus"
#   # region = ""
#   #
#   ## The Azure Resource ID against which metric will be logged, e.g.
#   ##   ex: resource_id = "/subscriptions/<subscription_id>/resourceGroups/<resource_group>/providers/Microsoft.Compute/virtualMachines/<vm_name>"
#   # resource_id = ""
#
#   ## Optionally, if in Azure US Government, China or other sovereign
#   ## cloud environment, set appropriate REST endpoint for receiving
#   ## metrics. (Note: region may be unused in this context)
#   # endpoint_url = "https://monitoring.core.usgovcloudapi.net"


# # Configuration for Google Cloud BigQuery to send entries
# [[outputs.bigquery]]
#   ## Credentials File
#   credentials_file = "/path/to/service/account/key.json"
#
#   ## Google Cloud Platform Project
#   project = "my-gcp-project"
#
#   ## The namespace for the metric descriptor
#   dataset = "telegraf"
#
#   ## Timeout for BigQuery operations.
#   # timeout = "5s"
#
#   ## Character to replace hyphens on Metric name
#   # replace_hyphen_to = "_"


# # Publish Telegraf metrics to a Google Cloud PubSub topic
# [[outputs.cloud_pubsub]]
#   ## Required. Name of Google Cloud Platform (GCP) Project that owns
#   ## the given PubSub topic.
#   project = "my-project"
#
#   ## Required. Name of PubSub topic to publish metrics to.
#   topic = "my-topic"
#
#   ## Required. Data format to consume.
#   ## Each data format has its own unique set of configuration options.
#   ## Read more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"
#
#   ## Optional. Filepath for GCP credentials JSON file to authorize calls to
#   ## PubSub APIs. If not set explicitly, Telegraf will attempt to use
#   ## Application Default Credentials, which is preferred.
#   # credentials_file = "path/to/my/creds.json"
#
#   ## Optional. If true, will send all metrics per write in one PubSub message.
#   # send_batched = true
#
#   ## The following publish_* parameters specifically configures batching
#   ## requests made to the GCP Cloud PubSub API via the PubSub Golang library. Read
#   ## more here: https://godoc.org/cloud.google.com/go/pubsub#PublishSettings
#
#   ## Optional. Send a request to PubSub (i.e. actually publish a batch)
#   ## when it has this many PubSub messages. If send_batched is true,
#   ## this is ignored and treated as if it were 1.
#   # publish_count_threshold = 1000
#
#   ## Optional. Send a request to PubSub (i.e. actually publish a batch)
#   ## when it has this many PubSub messages. If send_batched is true,
#   ## this is ignored and treated as if it were 1
#   # publish_byte_threshold = 1000000
#
#   ## Optional. Specifically configures requests made to the PubSub API.
#   # publish_num_go_routines = 2
#
#   ## Optional. Specifies a timeout for requests to the PubSub API.
#   # publish_timeout = "30s"
#
#   ## Optional. If true, published PubSub message data will be base64-encoded.
#   # base64_data = false
#
#   ## Optional. PubSub attributes to add to metrics.
#   # [outputs.cloud_pubsub.attributes]
#   #   my_attr = "tag_value"


# # Configuration for AWS CloudWatch output.
# [[outputs.cloudwatch]]
#   ## Amazon REGION
#   region = "us-east-1"
#
#   ## Amazon Credentials
#   ## Credentials are loaded in the following order
#   ## 1) Web identity provider credentials via STS if role_arn and web_identity_token_file are specified
#   ## 2) Assumed credentials via STS if role_arn is specified
#   ## 3) explicit credentials from 'access_key' and 'secret_key'
#   ## 4) shared profile from 'profile'
#   ## 5) environment variables
#   ## 6) shared credentials file
#   ## 7) EC2 Instance Profile
#   #access_key = ""
#   #secret_key = ""
#   #token = ""
#   #role_arn = ""
#   #web_identity_token_file = ""
#   #role_session_name = ""
#   #profile = ""
#   #shared_credential_file = ""
#
#   ## Endpoint to make request against, the correct endpoint is automatically
#   ## determined and this option should only be set if you wish to override the
#   ## default.
#   ##   ex: endpoint_url = "http://localhost:8000"
#   # endpoint_url = ""
#
#   ## Namespace for the CloudWatch MetricDatums
#   namespace = "InfluxData/Telegraf"
#
#   ## If you have a large amount of metrics, you should consider to send statistic
#   ## values instead of raw metrics which could not only improve performance but
#   ## also save AWS API cost. If enable this flag, this plugin would parse the required
#   ## CloudWatch statistic fields (count, min, max, and sum) and send them to CloudWatch.
#   ## You could use basicstats aggregator to calculate those fields. If not all statistic
#   ## fields are available, all fields would still be sent as raw metrics.
#   # write_statistics = false
#
#   ## Enable high resolution metrics of 1 second (if not enabled, standard resolution are of 60 seconds precision)
#   # high_resolution_metrics = false


# # Configuration for AWS CloudWatchLogs output.
# [[outputs.cloudwatch_logs]]
# ## The region is the Amazon region that you wish to connect to.
# ## Examples include but are not limited to:
# ## - us-west-1
# ## - us-west-2
# ## - us-east-1
# ## - ap-southeast-1
# ## - ap-southeast-2
# ## ...
# region = "us-east-1"
#
# ## Amazon Credentials
# ## Credentials are loaded in the following order
# ## 1) Web identity provider credentials via STS if role_arn and web_identity_token_file are specified
# ## 2) Assumed credentials via STS if role_arn is specified
# ## 3) explicit credentials from 'access_key' and 'secret_key'
# ## 4) shared profile from 'profile'
# ## 5) environment variables
# ## 6) shared credentials file
# ## 7) EC2 Instance Profile
# #access_key = ""
# #secret_key = ""
# #token = ""
# #role_arn = ""
# #web_identity_token_file = ""
# #role_session_name = ""
# #profile = ""
# #shared_credential_file = ""
#
# ## Endpoint to make request against, the correct endpoint is automatically
# ## determined and this option should only be set if you wish to override the
# ## default.
# ##   ex: endpoint_url = "http://localhost:8000"
# # endpoint_url = ""
#
# ## Cloud watch log group. Must be created in AWS cloudwatch logs upfront!
# ## For example, you can specify the name of the k8s cluster here to group logs from all cluster in oine place
# log_group = "my-group-name"
#
# ## Log stream in log group
# ## Either log group name or reference to metric attribute, from which it can be parsed:
# ## tag:<TAG_NAME> or field:<FIELD_NAME>. If log stream is not exist, it will be created.
# ## Since AWS is not automatically delete logs streams with expired logs entries (i.e. empty log stream)
# ## you need to put in place appropriate house-keeping (https://forums.aws.amazon.com/thread.jspa?threadID=178855)
# log_stream = "tag:location"
#
# ## Source of log data - metric name
# ## specify the name of the metric, from which the log data should be retrieved.
# ## I.e., if you  are using docker_log plugin to stream logs from container, then
# ## specify log_data_metric_name  = "docker_log"
# log_data_metric_name  = "docker_log"
#
# ## Specify from which metric attribute the log data should be retrieved:
# ## tag:<TAG_NAME> or field:<FIELD_NAME>.
# ## I.e., if you  are using docker_log plugin to stream logs from container, then
# ## specify log_data_source  = "field:message"
# log_data_source  = "field:message"


# # Configuration for CrateDB to send metrics to.
# [[outputs.cratedb]]
#   # A github.com/jackc/pgx/v4 connection string.
#   # See https://pkg.go.dev/github.com/jackc/pgx/v4#ParseConfig
#   url = "postgres://user:password@localhost/schema?sslmode=disable"
#   # Timeout for all CrateDB queries.
#   timeout = "5s"
#   # Name of the table to store metrics in.
#   table = "metrics"
#   # If true, and the metrics table does not exist, create it automatically.
#   table_create = true
#   # The character(s) to replace any '.' in an object key with
#   key_separator = "_"


# # Configuration for DataDog API to send metrics to.
# [[outputs.datadog]]
#   ## Datadog API key
#   apikey = "my-secret-key"
#
#   ## Connection timeout.
#   # timeout = "5s"
#
#   ## Write URL override; useful for debugging.
#   # url = "https://app.datadoghq.com/api/v1/series"
#
#   ## Set http_proxy (telegraf uses the system wide proxy settings if it isn't set)
#   # http_proxy_url = "http://localhost:8888"
#
#   ## Override the default (none) compression used to send data.
#   ## Supports: "zlib", "none"
#   # compression = "none"


# # Send metrics to nowhere at all
# [[outputs.discard]]
#   # no configuration


# # Send telegraf metrics to a Dynatrace environment
# [[outputs.dynatrace]]
#   ## For usage with the Dynatrace OneAgent you can omit any configuration,
#   ## the only requirement is that the OneAgent is running on the same host.
#   ## Only setup environment url and token if you want to monitor a Host without the OneAgent present.
#   ##
#   ## Your Dynatrace environment URL.
#   ## For Dynatrace OneAgent you can leave this empty or set it to "http://127.0.0.1:14499/metrics/ingest" (default)
#   ## For Dynatrace SaaS environments the URL scheme is "https://{your-environment-id}.live.dynatrace.com/api/v2/metrics/ingest"
#   ## For Dynatrace Managed environments the URL scheme is "https://{your-domain}/e/{your-environment-id}/api/v2/metrics/ingest"
#   url = ""
#
#   ## Your Dynatrace API token.
#   ## Create an API token within your Dynatrace environment, by navigating to Settings > Integration > Dynatrace API
#   ## The API token needs data ingest scope permission. When using OneAgent, no API token is required.
#   api_token = ""
#
#   ## Optional prefix for metric names (e.g.: "telegraf")
#   prefix = "telegraf"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#
#   ## Optional flag for ignoring tls certificate check
#   # insecure_skip_verify = false
#
#
#   ## Connection timeout, defaults to "5s" if not set.
#   timeout = "5s"
#
#   ## If you want metrics to be treated and reported as delta counters, add the metric names here
#   additional_counters = [ ]
#
#   ## Optional dimensions to be added to every metric
#   # [outputs.dynatrace.default_dimensions]
#   # default_key = "default value"


# # Configuration for Elasticsearch to send metrics to.
# [[outputs.elasticsearch]]
#   ## The full HTTP endpoint URL for your Elasticsearch instance
#   ## Multiple urls can be specified as part of the same cluster,
#   ## this means that only ONE of the urls will be written to each interval.
#   urls = [ "http://node1.es.example.com:9200" ] # required.
#   ## Elasticsearch client timeout, defaults to "5s" if not set.
#   timeout = "5s"
#   ## Set to true to ask Elasticsearch a list of all cluster nodes,
#   ## thus it is not necessary to list all nodes in the urls config option.
#   enable_sniffer = false
#   ## Set to true to enable gzip compression
#   enable_gzip = false
#   ## Set the interval to check if the Elasticsearch nodes are available
#   ## Setting to "0s" will disable the health check (not recommended in production)
#   health_check_interval = "10s"
#   ## HTTP basic authentication details
#   # username = "telegraf"
#   # password = "mypassword"
#   ## HTTP bearer token authentication details
#   # auth_bearer_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"
#
#   ## Index Config
#   ## The target index for metrics (Elasticsearch will create if it not exists).
#   ## You can use the date specifiers below to create indexes per time frame.
#   ## The metric timestamp will be used to decide the destination index name
#   # %Y - year (2016)
#   # %y - last two digits of year (00..99)
#   # %m - month (01..12)
#   # %d - day of month (e.g., 01)
#   # %H - hour (00..23)
#   # %V - week of the year (ISO week) (01..53)
#   ## Additionally, you can specify a tag name using the notation {{tag_name}}
#   ## which will be used as part of the index name. If the tag does not exist,
#   ## the default tag value will be used.
#   # index_name = "telegraf-{{host}}-%Y.%m.%d"
#   # default_tag_value = "none"
#   index_name = "telegraf-%Y.%m.%d" # required.
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Template Config
#   ## Set to true if you want telegraf to manage its index template.
#   ## If enabled it will create a recommended index template for telegraf indexes
#   manage_template = true
#   ## The template name used for telegraf indexes
#   template_name = "telegraf"
#   ## Set to true if you want telegraf to overwrite an existing template
#   overwrite_template = false
#   ## If set to true a unique ID hash will be sent as sha256(concat(timestamp,measurement,series-hash)) string
#   ## it will enable data resend and update metric points avoiding duplicated metrics with diferent id's
#   force_document_id = false
#
#   ## Specifies the handling of NaN and Inf values.
#   ## This option can have the following values:
#   ##    none    -- do not modify field-values (default); will produce an error if NaNs or infs are encountered
#   ##    drop    -- drop fields containing NaNs or infs
#   ##    replace -- replace with the value in "float_replacement_value" (default: 0.0)
#   ##               NaNs and inf will be replaced with the given number, -inf with the negative of that number
#   # float_handling = "none"
#   # float_replacement_value = 0.0
#
#   ## Pipeline Config
#   ## To use a ingest pipeline, set this to the name of the pipeline you want to use.
#   # use_pipeline = "my_pipeline"
#   ## Additionally, you can specify a tag name using the notation {{tag_name}}
#   ## which will be used as part of the pipeline name. If the tag does not exist,
#   ## the default pipeline will be used as the pipeline. If no default pipeline is set,
#   ## no pipeline is used for the metric.
#   # use_pipeline = "{{es_pipeline}}"
#   # default_pipeline = "my_pipeline"


# # Configuration for Event Hubs output plugin
# [[outputs.event_hubs]]
#   ## The full connection string to the Event Hub (required)
#   ## The shared access key must have "Send" permissions on the target Event Hub.
#   connection_string = "Endpoint=sb://namespace.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=superSecret1234=;EntityPath=hubName"
#
#   ## Client timeout (defaults to 30s)
#   # timeout = "30s"
#
#   ## Data format to output.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "json"


# # Send metrics to command as input over stdin
# [[outputs.exec]]
#   ## Command to ingest metrics via stdin.
#   command = ["tee", "-a", "/dev/null"]
#
#   ## Timeout for command to complete.
#   # timeout = "5s"
#
#   ## Data format to output.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   # data_format = "influx"


# # Run executable as long-running output plugin
# [[outputs.execd]]
#   ## Program to run as daemon
#   command = ["my-telegraf-output", "--some-flag", "value"]
#
#   ## Delay before the process is restarted after an unexpected termination
#   restart_delay = "10s"
#
#   ## Data format to export.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "influx"


# # Send telegraf metrics to file(s)
# [[outputs.file]]
#   ## Files to write to, "stdout" is a specially handled file.
#   files = ["stdout", "/tmp/metrics.out"]
#
#   ## Use batch serialization format instead of line based delimiting.  The
#   ## batch format allows for the production of non line based output formats and
#   ## may more efficiently encode metric groups.
#   # use_batch_format = false
#
#   ## The file will be rotated after the time interval specified.  When set
#   ## to 0 no time based rotation is performed.
#   # rotation_interval = "0d"
#
#   ## The logfile will be rotated when it becomes larger than the specified
#   ## size.  When set to 0 no size based rotation is performed.
#   # rotation_max_size = "0MB"
#
#   ## Maximum number of rotated archives to keep, any older logs are deleted.
#   ## If set to -1, no archives are removed.
#   # rotation_max_archives = 5
#
#   ## Data format to output.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "influx"


# # Configuration for Graphite server to send metrics to
# [[outputs.graphite]]
#   ## TCP endpoint for your graphite instance.
#   ## If multiple endpoints are configured, output will be load balanced.
#   ## Only one of the endpoints will be written to with each iteration.
#   servers = ["localhost:2003"]
#   ## Prefix metrics name
#   prefix = ""
#   ## Graphite output template
#   ## see https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   template = "host.tags.measurement.field"
#
#   ## Enable Graphite tags support
#   # graphite_tag_support = false
#
#   ## Define how metric names and tags are sanitized; options are "strict", or "compatible"
#   ## strict - Default method, and backwards compatible with previous versionf of Telegraf
#   ## compatible - More relaxed sanitizing when using tags, and compatible with the graphite spec
#   # graphite_tag_sanitize_mode = "strict"
#
#   ## Character for separating metric name and field for Graphite tags
#   # graphite_separator = "."
#
#   ## Graphite templates patterns
#   ## 1. Template for cpu
#   ## 2. Template for disk*
#   ## 3. Default template
#   # templates = [
#   #  "cpu tags.measurement.host.field",
#   #  "disk* measurement.field",
#   #  "host.measurement.tags.field"
#   #]
#
#   ## timeout in seconds for the write connection to graphite
#   timeout = 2
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Send telegraf metrics to graylog
# [[outputs.graylog]]
#   ## Endpoints for your graylog instances.
#   servers = ["udp://127.0.0.1:12201"]
#
#   ## Connection timeout.
#   # timeout = "5s"
#
#   ## The field to use as the GELF short_message, if unset the static string
#   ## "telegraf" will be used.
#   ##   example: short_message_field = "message"
#   # short_message_field = ""
#
#   ## According to GELF payload specification, additional fields names must be prefixed
#   ## with an underscore. Previous versions did not prefix custom field 'name' with underscore.
#   ## Set to true for backward compatibility.
#   # name_field_no_prefix = false
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Send telegraf metrics to GroundWork Monitor
# [[outputs.groundwork]]
#   ## URL of your groundwork instance.
#   url = "https://groundwork.example.com"
#
#   ## Agent uuid for GroundWork API Server.
#   agent_id = ""
#
#   ## Username and password to access GroundWork API.
#   username = ""
#   password = ""
#
#   ## Default display name for the host with services(metrics).
#   # default_host = "telegraf"
#
#   ## Default service state.
#   # default_service_state = "SERVICE_OK"
#
#   ## The name of the tag that contains the hostname.
#   # resource_tag = "host"
#
#   ## The name of the tag that contains the host group name.
#   # group_tag = "group"


# # Configurable HTTP health check resource based on metrics
# [[outputs.health]]
#   ## Address and port to listen on.
#   ##   ex: service_address = "http://localhost:8080"
#   ##       service_address = "unix:///var/run/telegraf-health.sock"
#   # service_address = "http://:8080"
#
#   ## The maximum duration for reading the entire request.
#   # read_timeout = "5s"
#   ## The maximum duration for writing the entire response.
#   # write_timeout = "5s"
#
#   ## Username and password to accept for HTTP basic authentication.
#   # basic_username = "user1"
#   # basic_password = "secret"
#
#   ## Allowed CA certificates for client certificates.
#   # tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## TLS server certificate and private key.
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#
#   ## One or more check sub-tables should be defined, it is also recommended to
#   ## use metric filtering to limit the metrics that flow into this output.
#   ##
#   ## When using the default buffer sizes, this example will fail when the
#   ## metric buffer is half full.
#   ##
#   ## namepass = ["internal_write"]
#   ## tagpass = { output = ["influxdb"] }
#   ##
#   ## [[outputs.health.compares]]
#   ##   field = "buffer_size"
#   ##   lt = 5000.0
#   ##
#   ## [[outputs.health.contains]]
#   ##   field = "buffer_size"


# # A plugin that can transmit metrics over HTTP
# [[outputs.http]]
#   ## URL is the address to send metrics to
#   url = "http://127.0.0.1:8080/telegraf"
#
#   ## Timeout for HTTP message
#   # timeout = "5s"
#
#   ## HTTP method, one of: "POST" or "PUT"
#   # method = "POST"
#
#   ## HTTP Basic Auth credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## OAuth2 Client Credentials Grant
#   # client_id = "clientid"
#   # client_secret = "secret"
#   # token_url = "https://indentityprovider/oauth2/v1/token"
#   # scopes = ["urn:opc:idm:__myscopes__"]
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Optional Cookie authentication
#   # cookie_auth_url = "https://localhost/authMe"
#   # cookie_auth_method = "POST"
#   # cookie_auth_username = "username"
#   # cookie_auth_password = "pa$$word"
#   # cookie_auth_headers = '{"Content-Type": "application/json", "X-MY-HEADER":"hello"}'
#   # cookie_auth_body = '{"username": "user", "password": "pa$$word", "authenticate": "me"}'
#   ## cookie_auth_renewal not set or set to "0" will auth once and never renew the cookie
#   # cookie_auth_renewal = "5m"
#
#   ## Data format to output.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   # data_format = "influx"
#
#   ## Use batch serialization format (default) instead of line based format.
#   ## Batch format is more efficient and should be used unless line based
#   ## format is really needed.
#   # use_batch_format = true
#
#   ## HTTP Content-Encoding for write request body, can be set to "gzip" to
#   ## compress body or "identity" to apply no encoding.
#   # content_encoding = "identity"
#
#   ## Additional HTTP headers
#   # [outputs.http.headers]
#   #   # Should be set manually to "application/json" for json data_format
#   #   Content-Type = "text/plain; charset=utf-8"
#
#   ## Idle (keep-alive) connection timeout.
#   ## Maximum amount of time before idle connection is closed.
#   ## Zero means no limit.
#   # idle_conn_timeout = 0
#
#   ## Amazon Region
#   #region = "us-east-1"
#
#   ## Amazon Credentials
#   ## Credentials are loaded in the following order
#   ## 1) Web identity provider credentials via STS if role_arn and web_identity_token_file are specified
#   ## 2) Assumed credentials via STS if role_arn is specified
#   ## 3) explicit credentials from 'access_key' and 'secret_key'
#   ## 4) shared profile from 'profile'
#   ## 5) environment variables
#   ## 6) shared credentials file
#   ## 7) EC2 Instance Profile
#   #access_key = ""
#   #secret_key = ""
#   #token = ""
#   #role_arn = ""
#   #web_identity_token_file = ""
#   #role_session_name = ""
#   #profile = ""
#   #shared_credential_file = ""


# # Configuration for sending metrics to InfluxDB
# [[outputs.influxdb_v2]]
#   ## The URLs of the InfluxDB cluster nodes.
#   ##
#   ## Multiple URLs can be specified for a single cluster, only ONE of the
#   ## urls will be written to each interval.
#   ##   ex: urls = ["https://us-west-2-1.aws.cloud2.influxdata.com"]
#   urls = ["http://127.0.0.1:8086"]
#
#   ## Token for authentication.
#   token = ""
#
#   ## Organization is the name of the organization you wish to write to; must exist.
#   organization = ""
#
#   ## Destination bucket to write into.
#   bucket = ""
#
#   ## The value of this tag will be used to determine the bucket.  If this
#   ## tag is not set the 'bucket' option is used as the default.
#   # bucket_tag = ""
#
#   ## If true, the bucket tag will not be added to the metric.
#   # exclude_bucket_tag = false
#
#   ## Timeout for HTTP messages.
#   # timeout = "5s"
#
#   ## Additional HTTP headers
#   # http_headers = {"X-Special-Header" = "Special-Value"}
#
#   ## HTTP Proxy override, if unset values the standard proxy environment
#   ## variables are consulted to determine which proxy, if any, should be used.
#   # http_proxy = "http://corporate.proxy:3128"
#
#   ## HTTP User-Agent
#   # user_agent = "telegraf"
#
#   ## Content-Encoding for write request body, can be set to "gzip" to
#   ## compress body or "identity" to apply no encoding.
#   # content_encoding = "gzip"
#
#   ## Enable or disable uint support for writing uints influxdb 2.0.
#   # influx_uint_support = false
#
#   ## Optional TLS Config for use on HTTP connections.
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Configuration for sending metrics to an Instrumental project
# [[outputs.instrumental]]
#   ## Project API Token (required)
#   api_token = "API Token" # required
#   ## Prefix the metrics with a given name
#   prefix = ""
#   ## Stats output template (Graphite formatting)
#   ## see https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md#graphite
#   template = "host.tags.measurement.field"
#   ## Timeout in seconds to connect
#   timeout = "2s"
#   ## Display Communication to Instrumental
#   debug = false


# # Configuration for the Kafka server to send metrics to
# [[outputs.kafka]]
#   ## URLs of kafka brokers
#   brokers = ["localhost:9092"]
#   ## Kafka topic for producer messages
#   topic = "telegraf"
#
#   ## The value of this tag will be used as the topic.  If not set the 'topic'
#   ## option is used.
#   # topic_tag = ""
#
#   ## If true, the 'topic_tag' will be removed from to the metric.
#   # exclude_topic_tag = false
#
#   ## Optional Client id
#   # client_id = "Telegraf"
#
#   ## Set the minimal supported Kafka version.  Setting this enables the use of new
#   ## Kafka features and APIs.  Of particular interest, lz4 compression
#   ## requires at least version 0.10.0.0.
#   ##   ex: version = "1.1.0"
#   # version = ""
#
#   ## Optional topic suffix configuration.
#   ## If the section is omitted, no suffix is used.
#   ## Following topic suffix methods are supported:
#   ##   measurement - suffix equals to separator + measurement's name
#   ##   tags        - suffix equals to separator + specified tags' values
#   ##                 interleaved with separator
#
#   ## Suffix equals to "_" + measurement name
#   # [outputs.kafka.topic_suffix]
#   #   method = "measurement"
#   #   separator = "_"
#
#   ## Suffix equals to "__" + measurement's "foo" tag value.
#   ##   If there's no such a tag, suffix equals to an empty string
#   # [outputs.kafka.topic_suffix]
#   #   method = "tags"
#   #   keys = ["foo"]
#   #   separator = "__"
#
#   ## Suffix equals to "_" + measurement's "foo" and "bar"
#   ##   tag values, separated by "_". If there is no such tags,
#   ##   their values treated as empty strings.
#   # [outputs.kafka.topic_suffix]
#   #   method = "tags"
#   #   keys = ["foo", "bar"]
#   #   separator = "_"
#
#   ## The routing tag specifies a tagkey on the metric whose value is used as
#   ## the message key.  The message key is used to determine which partition to
#   ## send the message to.  This tag is prefered over the routing_key option.
#   routing_tag = "host"
#
#   ## The routing key is set as the message key and used to determine which
#   ## partition to send the message to.  This value is only used when no
#   ## routing_tag is set or as a fallback when the tag specified in routing tag
#   ## is not found.
#   ##
#   ## If set to "random", a random value will be generated for each message.
#   ##
#   ## When unset, no message key is added and each message is routed to a random
#   ## partition.
#   ##
#   ##   ex: routing_key = "random"
#   ##       routing_key = "telegraf"
#   # routing_key = ""
#
#   ## Compression codec represents the various compression codecs recognized by
#   ## Kafka in messages.
#   ##  0 : None
#   ##  1 : Gzip
#   ##  2 : Snappy
#   ##  3 : LZ4
#   ##  4 : ZSTD
#   # compression_codec = 0
#
#   ## Idempotent Writes
#   ## If enabled, exactly one copy of each message is written.
#   # idempotent_writes = false
#
#   ##  RequiredAcks is used in Produce Requests to tell the broker how many
#   ##  replica acknowledgements it must see before responding
#   ##   0 : the producer never waits for an acknowledgement from the broker.
#   ##       This option provides the lowest latency but the weakest durability
#   ##       guarantees (some data will be lost when a server fails).
#   ##   1 : the producer gets an acknowledgement after the leader replica has
#   ##       received the data. This option provides better durability as the
#   ##       client waits until the server acknowledges the request as successful
#   ##       (only messages that were written to the now-dead leader but not yet
#   ##       replicated will be lost).
#   ##   -1: the producer gets an acknowledgement after all in-sync replicas have
#   ##       received the data. This option provides the best durability, we
#   ##       guarantee that no messages will be lost as long as at least one in
#   ##       sync replica remains.
#   # required_acks = -1
#
#   ## The maximum number of times to retry sending a metric before failing
#   ## until the next flush.
#   # max_retry = 3
#
#   ## The maximum permitted size of a message. Should be set equal to or
#   ## smaller than the broker's 'message.max.bytes'.
#   # max_message_bytes = 1000000
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Optional SOCKS5 proxy to use when connecting to brokers
#   # socks5_enabled = true
#   # socks5_address = "127.0.0.1:1080"
#   # socks5_username = "alice"
#   # socks5_password = "pass123"
#
#   ## Optional SASL Config
#   # sasl_username = "kafka"
#   # sasl_password = "secret"
#
#   ## Optional SASL:
#   ## one of: OAUTHBEARER, PLAIN, SCRAM-SHA-256, SCRAM-SHA-512, GSSAPI
#   ## (defaults to PLAIN)
#   # sasl_mechanism = ""
#
#   ## used if sasl_mechanism is GSSAPI (experimental)
#   # sasl_gssapi_service_name = ""
#   # ## One of: KRB5_USER_AUTH and KRB5_KEYTAB_AUTH
#   # sasl_gssapi_auth_type = "KRB5_USER_AUTH"
#   # sasl_gssapi_kerberos_config_path = "/"
#   # sasl_gssapi_realm = "realm"
#   # sasl_gssapi_key_tab_path = ""
#   # sasl_gssapi_disable_pafxfast = false
#
#   ## used if sasl_mechanism is OAUTHBEARER (experimental)
#   # sasl_access_token = ""
#
#   ## SASL protocol version.  When connecting to Azure EventHub set to 0.
#   # sasl_version = 1
#
#   # Disable Kafka metadata full fetch
#   # metadata_full = false
#
#   ## Data format to output.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   # data_format = "influx"


# # Configuration for the AWS Kinesis output.
# [[outputs.kinesis]]
#   ## Amazon REGION of kinesis endpoint.
#   region = "ap-southeast-2"
#
#   ## Amazon Credentials
#   ## Credentials are loaded in the following order
#   ## 1) Web identity provider credentials via STS if role_arn and web_identity_token_file are specified
#   ## 2) Assumed credentials via STS if role_arn is specified
#   ## 3) explicit credentials from 'access_key' and 'secret_key'
#   ## 4) shared profile from 'profile'
#   ## 5) environment variables
#   ## 6) shared credentials file
#   ## 7) EC2 Instance Profile
#   #access_key = ""
#   #secret_key = ""
#   #token = ""
#   #role_arn = ""
#   #web_identity_token_file = ""
#   #role_session_name = ""
#   #profile = ""
#   #shared_credential_file = ""
#
#   ## Endpoint to make request against, the correct endpoint is automatically
#   ## determined and this option should only be set if you wish to override the
#   ## default.
#   ##   ex: endpoint_url = "http://localhost:8000"
#   # endpoint_url = ""
#
#   ## Kinesis StreamName must exist prior to starting telegraf.
#   streamname = "StreamName"
#
#   ## The partition key can be calculated using one of several methods:
#   ##
#   ## Use a static value for all writes:
#   #  [outputs.kinesis.partition]
#   #    method = "static"
#   #    key = "howdy"
#   #
#   ## Use a random partition key on each write:
#   #  [outputs.kinesis.partition]
#   #    method = "random"
#   #
#   ## Use the measurement name as the partition key:
#   #  [outputs.kinesis.partition]
#   #    method = "measurement"
#   #
#   ## Use the value of a tag for all writes, if the tag is not set the empty
#   ## default option will be used. When no default, defaults to "telegraf"
#   #  [outputs.kinesis.partition]
#   #    method = "tag"
#   #    key = "host"
#   #    default = "mykey"
#
#
#   ## Data format to output.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "influx"
#
#   ## debug will show upstream aws messages.
#   debug = false


# # Configuration for Librato API to send metrics to.
# [[outputs.librato]]
#   ## Librato API Docs
#   ## http://dev.librato.com/v1/metrics-authentication
#   ## Librato API user
#   api_user = "telegraf@influxdb.com" # required.
#   ## Librato API token
#   api_token = "my-secret-token" # required.
#   ## Debug
#   # debug = false
#   ## Connection timeout.
#   # timeout = "5s"
#   ## Output source Template (same as graphite buckets)
#   ## see https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md#graphite
#   ## This template is used in librato's source (not metric's name)
#   template = "host"
#


# # Send aggregate metrics to Logz.io
# [[outputs.logzio]]
#   ## Connection timeout, defaults to "5s" if not set.
#   timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#
#   ## Logz.io account token
#   token = "your logz.io token" # required
#
#   ## Use your listener URL for your Logz.io account region.
#   # url = "https://listener.logz.io:8071"


# # Send logs to Loki
# [[outputs.loki]]
#   ## The domain of Loki
#   domain = "https://loki.domain.tld"
#
#   ## Endpoint to write api
#   # endpoint = "/loki/api/v1/push"
#
#   ## Connection timeout, defaults to "5s" if not set.
#   # timeout = "5s"
#
#   ## Basic auth credential
#   # username = "loki"
#   # password = "pass"
#
#   ## Additional HTTP headers
#   # http_headers = {"X-Scope-OrgID" = "1"}
#
#   ## If the request must be gzip encoded
#   # gzip_request = false
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"


# # Sends metrics to MongoDB
# [[outputs.mongodb]]
#   # connection string examples for mongodb
#   dsn = "mongodb://localhost:27017"
#   # dsn = "mongodb://mongod1:27017,mongod2:27017,mongod3:27017/admin&replicaSet=myReplSet&w=1"
#
#   # overrides serverSelectionTimeoutMS in dsn if set
#   # timeout = "30s"
#
#   # default authentication, optional
#   # authentication = "NONE"
#
#   # for SCRAM-SHA-256 authentication
#   # authentication = "SCRAM"
#   # username = "root"
#   # password = "***"
#
#   # for x509 certificate authentication
#   # authentication = "X509"
#   # tls_ca = "ca.pem"
#   # tls_key = "client.pem"
#   # # tls_key_pwd = "changeme" # required for encrypted tls_key
#   # insecure_skip_verify = false
#
#   # database to store measurements and time series collections
#   # database = "telegraf"
#
#   # granularity can be seconds, minutes, or hours.
#   # configuring this value will be based on your input collection frequency.
#   # see https://docs.mongodb.com/manual/core/timeseries-collections/#create-a-time-series-collection
#   # granularity = "seconds"
#
#   # optionally set a TTL to automatically expire documents from the measurement collections.
#   # ttl = "360h"


# # Configuration for MQTT server to send metrics to
# [[outputs.mqtt]]
#   ## MQTT Brokers
#   ## The list of brokers should only include the hostname or IP address and the
#   ## port to the broker. This should follow the format '{host}:{port}'. For
#   ## example, "localhost:1883" or "127.0.0.1:8883".
#   servers = ["localhost:1883"]
#
#   ## MQTT Topic for Producer Messages
#   ## MQTT outputs send metrics to this topic format:
#   ## <topic_prefix>/<hostname>/<pluginname>/ (e.g. prefix/web01.example.com/mem)
#   topic_prefix = "telegraf"
#
#   ## QoS policy for messages
#   ## The mqtt QoS policy for sending messages.
#   ## See https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_9.0.0/com.ibm.mq.dev.doc/q029090_.htm
#   ##   0 = at most once
#   ##   1 = at least once
#   ##   2 = exactly once
#   # qos = 2
#
#   ## Keep Alive
#   ## Defines the maximum length of time that the broker and client may not
#   ## communicate. Defaults to 0 which turns the feature off.
#   ##
#   ## For version v2.0.12 and later mosquitto there is a bug
#   ## (see https://github.com/eclipse/mosquitto/issues/2117), which requires
#   ## this to be non-zero. As a reference eclipse/paho.mqtt.golang defaults to 30.
#   # keep_alive = 0
#
#   ## username and password to connect MQTT server.
#   # username = "telegraf"
#   # password = "metricsmetricsmetricsmetrics"
#
#   ## client ID
#   ## The unique client id to connect MQTT server. If this parameter is not set
#   ## then a random ID is generated.
#   # client_id = ""
#
#   ## Timeout for write operations. default: 5s
#   # timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## When true, metrics will be sent in one MQTT message per flush. Otherwise,
#   ## metrics are written one metric per MQTT message.
#   # batch = false
#
#   ## When true, metric will have RETAIN flag set, making broker cache entries until someone
#   ## actually reads it
#   # retain = false
#
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "influx"


# # Send telegraf measurements to NATS
# [[outputs.nats]]
#   ## URLs of NATS servers
#   servers = ["nats://localhost:4222"]
#
#   ## Optional client name
#   # name = ""
#
#   ## Optional credentials
#   # username = ""
#   # password = ""
#
#   ## Optional NATS 2.0 and NATS NGS compatible user credentials
#   # credentials = "/etc/telegraf/nats.creds"
#
#   ## NATS subject for producer messages
#   subject = "telegraf"
#
#   ## Use Transport Layer Security
#   # secure = false
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Data format to output.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "influx"


# # Send metrics to New Relic metrics endpoint
# [[outputs.newrelic]]
#   ## The 'insights_key' parameter requires a NR license key.
#   ## New Relic recommends you create one
#   ## with a convenient name such as TELEGRAF_INSERT_KEY.
#   ## reference: https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/#ingest-license-key
#   # insights_key = "New Relic License Key Here"
#
#   ## Prefix to add to add to metric name for easy identification.
#   ## This is very useful if your metric names are ambiguous.
#   # metric_prefix = ""
#
#   ## Timeout for writes to the New Relic API.
#   # timeout = "15s"
#
#   ## HTTP Proxy override. If unset use values from the standard
#   ## proxy environment variables to determine proxy, if any.
#   # http_proxy = "http://corporate.proxy:3128"
#
#   ## Metric URL override to enable geographic location endpoints.
#   # If not set use values from the standard
#   # metric_url = "https://metric-api.newrelic.com/metric/v1"


# # Send telegraf measurements to NSQD
# [[outputs.nsq]]
#   ## Location of nsqd instance listening on TCP
#   server = "localhost:4150"
#   ## NSQ topic for producer messages
#   topic = "telegraf"
#
#   ## Data format to output.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   data_format = "influx"


# # Send OpenTelemetry metrics over gRPC
# [[outputs.opentelemetry]]
#   ## Override the default (localhost:4317) OpenTelemetry gRPC service
#   ## address:port
#   # service_address = "localhost:4317"
#
#   ## Override the default (5s) request timeout
#   # timeout = "5s"
#
#   ## Optional TLS Config.
#   ##
#   ## Root certificates for verifying server certificates encoded in PEM format.
#   # tls_ca = "/etc/telegraf/ca.pem"
#   ## The public and private keypairs for the client encoded in PEM format.
#   ## May contain intermediate certificates.
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS, but skip TLS chain and host verification.
#   # insecure_skip_verify = false
#   ## Send the specified TLS server name via SNI.
#   # tls_server_name = "foo.example.com"
#
#   ## Override the default (gzip) compression used to send data.
#   ## Supports: "gzip", "none"
#   # compression = "gzip"
#
#   ## Additional OpenTelemetry resource attributes
#   # [outputs.opentelemetry.attributes]
#   # "service.name" = "demo"
#
#   ## Additional gRPC request metadata
#   # [outputs.opentelemetry.headers]
#   # key1 = "value1"


# # Configuration for OpenTSDB server to send metrics to
# [[outputs.opentsdb]]
#   ## prefix for metrics keys
#   prefix = "my.specific.prefix."
#
#   ## DNS name of the OpenTSDB server
#   ## Using "opentsdb.example.com" or "tcp://opentsdb.example.com" will use the
#   ## telnet API. "http://opentsdb.example.com" will use the Http API.
#   host = "opentsdb.example.com"
#
#   ## Port of the OpenTSDB server
#   port = 4242
#
#   ## Number of data points to send to OpenTSDB in Http requests.
#   ## Not used with telnet API.
#   http_batch_size = 50
#
#   ## URI Path for Http requests to OpenTSDB.
#   ## Used in cases where OpenTSDB is located behind a reverse proxy.
#   http_path = "/api/put"
#
#   ## Debug true - Prints OpenTSDB communication
#   debug = false
#
#   ## Separator separates measurement name from field
#   separator = "_"


# # Configuration for the Prometheus client to spawn
# [[outputs.prometheus_client]]
#   ## Address to listen on
#   listen = ":9273"
#
#   ## Metric version controls the mapping from Telegraf metrics into
#   ## Prometheus format.  When using the prometheus input, use the same value in
#   ## both plugins to ensure metrics are round-tripped without modification.
#   ##
#   ##   example: metric_version = 1;
#   ##            metric_version = 2; recommended version
#   # metric_version = 1
#
#   ## Use HTTP Basic Authentication.
#   # basic_username = "Foo"
#   # basic_password = "Bar"
#
#   ## If set, the IP Ranges which are allowed to access metrics.
#   ##   ex: ip_range = ["192.168.0.0/24", "192.168.1.0/30"]
#   # ip_range = []
#
#   ## Path to publish the metrics on.
#   # path = "/metrics"
#
#   ## Expiration interval for each metric. 0 == no expiration
#   # expiration_interval = "60s"
#
#   ## Collectors to enable, valid entries are "gocollector" and "process".
#   ## If unset, both are enabled.
#   # collectors_exclude = ["gocollector", "process"]
#
#   ## Send string metrics as Prometheus labels.
#   ## Unless set to false all string metrics will be sent as labels.
#   # string_as_label = true
#
#   ## If set, enable TLS with the given certificate.
#   # tls_cert = "/etc/ssl/telegraf.crt"
#   # tls_key = "/etc/ssl/telegraf.key"
#
#   ## Set one or more allowed client CA certificate file names to
#   ## enable mutually authenticated TLS connections
#   # tls_allowed_cacerts = ["/etc/telegraf/clientca.pem"]
#
#   ## Export metric collection time.
#   # export_timestamp = false


# # Configuration for the Riemann server to send metrics to
# [[outputs.riemann]]
#   ## The full TCP or UDP URL of the Riemann server
#   url = "tcp://localhost:5555"
#
#   ## Riemann event TTL, floating-point time in seconds.
#   ## Defines how long that an event is considered valid for in Riemann
#   # ttl = 30.0
#
#   ## Separator to use between measurement and field name in Riemann service name
#   ## This does not have any effect if 'measurement_as_attribute' is set to 'true'
#   separator = "/"
#
#   ## Set measurement name as Riemann attribute 'measurement', instead of prepending it to the Riemann service name
#   # measurement_as_attribute = false
#
#   ## Send string metrics as Riemann event states.
#   ## Unless enabled all string metrics will be ignored
#   # string_as_state = false
#
#   ## A list of tag keys whose values get sent as Riemann tags.
#   ## If empty, all Telegraf tag values will be sent as tags
#   # tag_keys = ["telegraf","custom_tag"]
#
#   ## Additional Riemann tags to send.
#   # tags = ["telegraf-output"]
#
#   ## Description for Riemann event
#   # description_text = "metrics collected from telegraf"
#
#   ## Riemann client write timeout, defaults to "5s" if not set.
#   # timeout = "5s"


# # Configuration for the Riemann server to send metrics to
# [[outputs.riemann_legacy]]
#   ## DEPRECATED: The 'riemann_legacy' plugin is deprecated in version 1.3.0, use 'outputs.riemann' instead (see https://github.com/influxdata/telegraf/issues/1878).
#   ## URL of server
#   url = "localhost:5555"
#   ## transport protocol to use either tcp or udp
#   transport = "tcp"
#   ## separator to use between input name and field name in Riemann service name
#   separator = " "


# # Send aggregate metrics to Sensu Monitor
# [[outputs.sensu]]
#   ## BACKEND API URL is the Sensu Backend API root URL to send metrics to
#   ## (protocol, host, and port only). The output plugin will automatically
#   ## append the corresponding backend API path
#   ## /api/core/v2/namespaces/:entity_namespace/events/:entity_name/:check_name).
#   ##
#   ## Backend Events API reference:
#   ## https://docs.sensu.io/sensu-go/latest/api/events/
#   ##
#   ## AGENT API URL is the Sensu Agent API root URL to send metrics to
#   ## (protocol, host, and port only). The output plugin will automatically
#   ## append the correspeonding agent API path (/events).
#   ##
#   ## Agent API Events API reference:
#   ## https://docs.sensu.io/sensu-go/latest/api/events/
#   ##
#   ## NOTE: if backend_api_url and agent_api_url and api_key are set, the output
#   ## plugin will use backend_api_url. If backend_api_url and agent_api_url are
#   ## not provided, the output plugin will default to use an agent_api_url of
#   ## http://127.0.0.1:3031
#   ##
#   # backend_api_url = "http://127.0.0.1:8080"
#   # agent_api_url = "http://127.0.0.1:3031"
#
#   ## API KEY is the Sensu Backend API token
#   ## Generate a new API token via:
#   ##
#   ## $ sensuctl cluster-role create telegraf --verb create --resource events,entities
#   ## $ sensuctl cluster-role-binding create telegraf --cluster-role telegraf --group telegraf
#   ## $ sensuctl user create telegraf --group telegraf --password REDACTED
#   ## $ sensuctl api-key grant telegraf
#   ##
#   ## For more information on Sensu RBAC profiles & API tokens, please visit:
#   ## - https://docs.sensu.io/sensu-go/latest/reference/rbac/
#   ## - https://docs.sensu.io/sensu-go/latest/reference/apikeys/
#   ##
#   # api_key = "${SENSU_API_KEY}"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Timeout for HTTP message
#   # timeout = "5s"
#
#   ## HTTP Content-Encoding for write request body, can be set to "gzip" to
#   ## compress body or "identity" to apply no encoding.
#   # content_encoding = "identity"
#
#   ## Sensu Event details
#   ##
#   ## Below are the event details to be sent to Sensu.  The main portions of the
#   ## event are the check, entity, and metrics specifications. For more information
#   ## on Sensu events and its components, please visit:
#   ## - Events - https://docs.sensu.io/sensu-go/latest/reference/events
#   ## - Checks -  https://docs.sensu.io/sensu-go/latest/reference/checks
#   ## - Entities - https://docs.sensu.io/sensu-go/latest/reference/entities
#   ## - Metrics - https://docs.sensu.io/sensu-go/latest/reference/events#metrics
#   ##
#   ## Check specification
#   ## The check name is the name to give the Sensu check associated with the event
#   ## created. This maps to check.metatadata.name in the event.
#   [outputs.sensu.check]
#   name = "telegraf"
#
#   ## Entity specification
#   ## Configure the entity name and namespace, if necessary. This will be part of
#   ## the entity.metadata in the event.
#   ##
#   ## NOTE: if the output plugin is configured to send events to a
#   ## backend_api_url and entity_name is not set, the value returned by
#   ## os.Hostname() will be used; if the output plugin is configured to send
#   ## events to an agent_api_url, entity_name and entity_namespace are not used.
#   # [outputs.sensu.entity]
#   #   name = "server-01"
#   #   namespace = "default"
#
#   ## Metrics specification
#   ## Configure the tags for the metrics that are sent as part of the Sensu event
#   # [outputs.sensu.tags]
#   #   source = "telegraf"
#
#   ## Configure the handler(s) for processing the provided metrics
#   # [outputs.sensu.metrics]
#   #   handlers = ["influxdb","elasticsearch"]


# # Send metrics and events to SignalFx
# [[outputs.signalfx]]
#     ## SignalFx Org Access Token
#     access_token = "my-secret-token"
#
#     ## The SignalFx realm that your organization resides in
#     signalfx_realm = "us9"  # Required if ingest_url is not set
#
#     ## You can optionally provide a custom ingest url instead of the
#     ## signalfx_realm option above if you are using a gateway or proxy
#     ## instance.  This option takes precident over signalfx_realm.
#     ingest_url = "https://my-custom-ingest/"
#
#     ## Event typed metrics are omitted by default,
#     ## If you require an event typed metric you must specify the
#     ## metric name in the following list.
#     included_event_names = ["plugin.metric_name"]


# # Generic socket writer capable of handling multiple socket types.
# [[outputs.socket_writer]]
#   ## URL to connect to
#   # address = "tcp://127.0.0.1:8094"
#   # address = "tcp://example.com:http"
#   # address = "tcp4://127.0.0.1:8094"
#   # address = "tcp6://127.0.0.1:8094"
#   # address = "tcp6://[2001:db8::1]:8094"
#   # address = "udp://127.0.0.1:8094"
#   # address = "udp4://127.0.0.1:8094"
#   # address = "udp6://127.0.0.1:8094"
#   # address = "unix:///tmp/telegraf.sock"
#   # address = "unixgram:///tmp/telegraf.sock"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Period between keep alive probes.
#   ## Only applies to TCP sockets.
#   ## 0 disables keep alive probes.
#   ## Defaults to the OS configuration.
#   # keep_alive_period = "5m"
#
#   ## Content encoding for packet-based connections (i.e. UDP, unixgram).
#   ## Can be set to "gzip" or to "identity" to apply no encoding.
#   ##
#   # content_encoding = "identity"
#
#   ## Data format to generate.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   # data_format = "influx"


# # Send metrics to SQL Database
# [[outputs.sql]]
#   ## Database driver
#   ## Valid options: mssql (Microsoft SQL Server), mysql (MySQL), pgx (Postgres),
#   ##  sqlite (SQLite3), snowflake (snowflake.com) clickhouse (ClickHouse)
#   # driver = ""
#
#   ## Data source name
#   ## The format of the data source name is different for each database driver.
#   ## See the plugin readme for details.
#   # data_source_name = ""
#
#   ## Timestamp column name
#   # timestamp_column = "timestamp"
#
#   ## Table creation template
#   ## Available template variables:
#   ##  {TABLE} - table name as a quoted identifier
#   ##  {TABLELITERAL} - table name as a quoted string literal
#   ##  {COLUMNS} - column definitions (list of quoted identifiers and types)
#   # table_template = "CREATE TABLE {TABLE}({COLUMNS})"
#
#   ## Table existence check template
#   ## Available template variables:
#   ##  {TABLE} - tablename as a quoted identifier
#   # table_exists_template = "SELECT 1 FROM {TABLE} LIMIT 1"
#
#   ## Initialization SQL
#   # init_sql = ""
#
#   ## Metric type to SQL type conversion
#   ## The values on the left are the data types Telegraf has and the values on
#   ## the right are the data types Telegraf will use when sending to a database.
#   ##
#   ## The database values used must be data types the destination database
#   ## understands. It is up to the user to ensure that the selected data type is
#   ## available in the database they are using. Refer to your database
#   ## documentation for what data types are available and supported.
#   #[outputs.sql.convert]
#   #  integer              = "INT"
#   #  real                 = "DOUBLE"
#   #  text                 = "TEXT"
#   #  timestamp            = "TIMESTAMP"
#   #  defaultvalue         = "TEXT"
#   #  unsigned             = "UNSIGNED"
#   #  bool                 = "BOOL"
#
#   ## This setting controls the behavior of the unsigned value. By default the
#   ## setting will take the integer value and append the unsigned value to it. The other
#   ## option is "literal", which will use the actual value the user provides to
#   ## the unsigned option. This is useful for a database like ClickHouse where
#   ## the unsigned value should use a value like "uint64".
#   # conversion_style = "unsigned_suffix"


# # Configuration for Google Cloud Stackdriver to send metrics to
# [[outputs.stackdriver]]
#   ## GCP Project
#   project = "erudite-bloom-151019"
#
#   ## The namespace for the metric descriptor
#   namespace = "telegraf"
#
#   ## Custom resource type
#   # resource_type = "generic_node"
#
#   ## Additional resource labels
#   # [outputs.stackdriver.resource_labels]
#   #   node_id = "$HOSTNAME"
#   #   namespace = "myapp"
#   #   location = "eu-north0"


# # A plugin that can transmit metrics to Sumo Logic HTTP Source
# [[outputs.sumologic]]
#   ## Unique URL generated for your HTTP Metrics Source.
#   ## This is the address to send metrics to.
#   # url = "https://events.sumologic.net/receiver/v1/http/<UniqueHTTPCollectorCode>"
#
#   ## Data format to be used for sending metrics.
#   ## This will set the "Content-Type" header accordingly.
#   ## Currently supported formats:
#   ## * graphite - for Content-Type of application/vnd.sumologic.graphite
#   ## * carbon2 - for Content-Type of application/vnd.sumologic.carbon2
#   ## * prometheus - for Content-Type of application/vnd.sumologic.prometheus
#   ##
#   ## More information can be found at:
#   ## https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/HTTP-Source/Upload-Metrics-to-an-HTTP-Source#content-type-headers-for-metrics
#   ##
#   ## NOTE:
#   ## When unset, telegraf will by default use the influx serializer which is currently unsupported
#   ## in HTTP Source.
#   data_format = "carbon2"
#
#   ## Timeout used for HTTP request
#   # timeout = "5s"
#
#   ## Max HTTP request body size in bytes before compression (if applied).
#   ## By default 1MB is recommended.
#   ## NOTE:
#   ## Bear in mind that in some serializer a metric even though serialized to multiple
#   ## lines cannot be split any further so setting this very low might not work
#   ## as expected.
#   # max_request_body_size = 1000000
#
#   ## Additional, Sumo specific options.
#   ## Full list can be found here:
#   ## https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/HTTP-Source/Upload-Metrics-to-an-HTTP-Source#supported-http-headers
#
#   ## Desired source name.
#   ## Useful if you want to override the source name configured for the source.
#   # source_name = ""
#
#   ## Desired host name.
#   ## Useful if you want to override the source host configured for the source.
#   # source_host = ""
#
#   ## Desired source category.
#   ## Useful if you want to override the source category configured for the source.
#   # source_category = ""
#
#   ## Comma-separated key=value list of dimensions to apply to every metric.
#   ## Custom dimensions will allow you to query your metrics at a more granular level.
#   # dimensions = ""


# # Configuration for Syslog server to send metrics to
# [[outputs.syslog]]
#   ## URL to connect to
#   ## ex: address = "tcp://127.0.0.1:8094"
#   ## ex: address = "tcp4://127.0.0.1:8094"
#   ## ex: address = "tcp6://127.0.0.1:8094"
#   ## ex: address = "tcp6://[2001:db8::1]:8094"
#   ## ex: address = "udp://127.0.0.1:8094"
#   ## ex: address = "udp4://127.0.0.1:8094"
#   ## ex: address = "udp6://127.0.0.1:8094"
#   address = "tcp://127.0.0.1:8094"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Period between keep alive probes.
#   ## Only applies to TCP sockets.
#   ## 0 disables keep alive probes.
#   ## Defaults to the OS configuration.
#   # keep_alive_period = "5m"
#
#   ## The framing technique with which it is expected that messages are
#   ## transported (default = "octet-counting").  Whether the messages come
#   ## using the octect-counting (RFC5425#section-4.3.1, RFC6587#section-3.4.1),
#   ## or the non-transparent framing technique (RFC6587#section-3.4.2).  Must
#   ## be one of "octet-counting", "non-transparent".
#   # framing = "octet-counting"
#
#   ## The trailer to be expected in case of non-transparent framing (default = "LF").
#   ## Must be one of "LF", or "NUL".
#   # trailer = "LF"
#
#   ## SD-PARAMs settings
#   ## Syslog messages can contain key/value pairs within zero or more
#   ## structured data sections.  For each unrecognized metric tag/field a
#   ## SD-PARAMS is created.
#   ##
#   ## Example:
#   ##   [[outputs.syslog]]
#   ##     sdparam_separator = "_"
#   ##     default_sdid = "default@32473"
#   ##     sdids = ["foo@123", "bar@456"]
#   ##
#   ##   input => xyzzy,x=y foo@123_value=42,bar@456_value2=84,something_else=1
#   ##   output (structured data only) => [foo@123 value=42][bar@456 value2=84][default@32473 something_else=1 x=y]
#
#   ## SD-PARAMs separator between the sdid and tag/field key (default = "_")
#   # sdparam_separator = "_"
#
#   ## Default sdid used for tags/fields that don't contain a prefix defined in
#   ## the explicit sdids setting below If no default is specified, no SD-PARAMs
#   ## will be used for unrecognized field.
#   # default_sdid = "default@32473"
#
#   ## List of explicit prefixes to extract from tag/field keys and use as the
#   ## SDID, if they match (see above example for more details):
#   # sdids = ["foo@123", "bar@456"]
#
#   ## Default severity value. Severity and Facility are used to calculate the
#   ## message PRI value (RFC5424#section-6.2.1).  Used when no metric field
#   ## with key "severity_code" is defined.  If unset, 5 (notice) is the default
#   # default_severity_code = 5
#
#   ## Default facility value. Facility and Severity are used to calculate the
#   ## message PRI value (RFC5424#section-6.2.1).  Used when no metric field with
#   ## key "facility_code" is defined.  If unset, 1 (user-level) is the default
#   # default_facility_code = 1
#
#   ## Default APP-NAME value (RFC5424#section-6.2.5)
#   ## Used when no metric tag with key "appname" is defined.
#   ## If unset, "Telegraf" is the default
#   # default_appname = "Telegraf"


# # Configuration for Amazon Timestream output.
# [[outputs.timestream]]
#   ## Amazon Region
#   region = "us-east-1"
#
#   ## Amazon Credentials
#   ## Credentials are loaded in the following order:
#   ## 1) Web identity provider credentials via STS if role_arn and web_identity_token_file are specified
#   ## 2) Assumed credentials via STS if role_arn is specified
#   ## 3) explicit credentials from 'access_key' and 'secret_key'
#   ## 4) shared profile from 'profile'
#   ## 5) environment variables
#   ## 6) shared credentials file
#   ## 7) EC2 Instance Profile
#   #access_key = ""
#   #secret_key = ""
#   #token = ""
#   #role_arn = ""
#   #web_identity_token_file = ""
#   #role_session_name = ""
#   #profile = ""
#   #shared_credential_file = ""
#
#   ## Endpoint to make request against, the correct endpoint is automatically
#   ## determined and this option should only be set if you wish to override the
#   ## default.
#   ##   ex: endpoint_url = "http://localhost:8000"
#   # endpoint_url = ""
#
#   ## Timestream database where the metrics will be inserted.
#   ## The database must exist prior to starting Telegraf.
#   database_name = "yourDatabaseNameHere"
#
#   ## Specifies if the plugin should describe the Timestream database upon starting
#   ## to validate if it has access necessary permissions, connection, etc., as a safety check.
#   ## If the describe operation fails, the plugin will not start
#   ## and therefore the Telegraf agent will not start.
#   describe_database_on_start = false
#
#   ## The mapping mode specifies how Telegraf records are represented in Timestream.
#   ## Valid values are: single-table, multi-table.
#   ## For example, consider the following data in line protocol format:
#   ## weather,location=us-midwest,season=summer temperature=82,humidity=71 1465839830100400200
#   ## airquality,location=us-west no2=5,pm25=16 1465839830100400200
#   ## where weather and airquality are the measurement names, location and season are tags,
#   ## and temperature, humidity, no2, pm25 are fields.
#   ## In multi-table mode:
#   ##  - first line will be ingested to table named weather
#   ##  - second line will be ingested to table named airquality
#   ##  - the tags will be represented as dimensions
#   ##  - first table (weather) will have two records:
#   ##      one with measurement name equals to temperature,
#   ##      another with measurement name equals to humidity
#   ##  - second table (airquality) will have two records:
#   ##      one with measurement name equals to no2,
#   ##      another with measurement name equals to pm25
#   ##  - the Timestream tables from the example will look like this:
#   ##      TABLE "weather":
#   ##        time | location | season | measure_name | measure_value::bigint
#   ##        2016-06-13 17:43:50 | us-midwest | summer | temperature | 82
#   ##        2016-06-13 17:43:50 | us-midwest | summer | humidity | 71
#   ##      TABLE "airquality":
#   ##        time | location | measure_name | measure_value::bigint
#   ##        2016-06-13 17:43:50 | us-west | no2 | 5
#   ##        2016-06-13 17:43:50 | us-west | pm25 | 16
#   ## In single-table mode:
#   ##  - the data will be ingested to a single table, which name will be valueOf(single_table_name)
#   ##  - measurement name will stored in dimension named valueOf(single_table_dimension_name_for_telegraf_measurement_name)
#   ##  - location and season will be represented as dimensions
#   ##  - temperature, humidity, no2, pm25 will be represented as measurement name
#   ##  - the Timestream table from the example will look like this:
#   ##      Assuming:
#   ##        - single_table_name = "my_readings"
#   ##        - single_table_dimension_name_for_telegraf_measurement_name = "namespace"
#   ##      TABLE "my_readings":
#   ##        time | location | season | namespace | measure_name | measure_value::bigint
#   ##        2016-06-13 17:43:50 | us-midwest | summer | weather | temperature | 82
#   ##        2016-06-13 17:43:50 | us-midwest | summer | weather | humidity | 71
#   ##        2016-06-13 17:43:50 | us-west | NULL | airquality | no2 | 5
#   ##        2016-06-13 17:43:50 | us-west | NULL | airquality | pm25 | 16
#   ## In most cases, using multi-table mapping mode is recommended.
#   ## However, you can consider using single-table in situations when you have thousands of measurement names.
#   mapping_mode = "multi-table"
#
#   ## Only valid and required for mapping_mode = "single-table"
#   ## Specifies the Timestream table where the metrics will be uploaded.
#   # single_table_name = "yourTableNameHere"
#
#   ## Only valid and required for mapping_mode = "single-table"
#   ## Describes what will be the Timestream dimension name for the Telegraf
#   ## measurement name.
#   # single_table_dimension_name_for_telegraf_measurement_name = "namespace"
#
#   ## Specifies if the plugin should create the table, if the table do not exist.
#   ## The plugin writes the data without prior checking if the table exists.
#   ## When the table does not exist, the error returned from Timestream will cause
#   ## the plugin to create the table, if this parameter is set to true.
#   create_table_if_not_exists = true
#
#   ## Only valid and required if create_table_if_not_exists = true
#   ## Specifies the Timestream table magnetic store retention period in days.
#   ## Check Timestream documentation for more details.
#   create_table_magnetic_store_retention_period_in_days = 365
#
#   ## Only valid and required if create_table_if_not_exists = true
#   ## Specifies the Timestream table memory store retention period in hours.
#   ## Check Timestream documentation for more details.
#   create_table_memory_store_retention_period_in_hours = 24
#
#   ## Only valid and optional if create_table_if_not_exists = true
#   ## Specifies the Timestream table tags.
#   ## Check Timestream documentation for more details
#   # create_table_tags = { "foo" = "bar", "environment" = "dev"}
#
#   ## Specify the maximum number of parallel go routines to ingest/write data
#   ## If not specified, defaulted to 1 go routines
#   max_write_go_routines = 25


# # Write metrics to Warp 10
# [[outputs.warp10]]
#   # Prefix to add to the measurement.
#   prefix = "telegraf."
#
#   # URL of the Warp 10 server
#   warp_url = "http://localhost:8080"
#
#   # Write token to access your app on warp 10
#   token = "Token"
#
#   # Warp 10 query timeout
#   # timeout = "15s"
#
#   ## Print Warp 10 error body
#   # print_error_body = false
#
#   ## Max string error size
#   # max_string_error_size = 511
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Configuration for Wavefront server to send metrics to
# [[outputs.wavefront]]
#   ## Url for Wavefront Direct Ingestion. For Wavefront Proxy Ingestion, see
#   ## the 'host' and 'port' optioins below.
#   url = "https://metrics.wavefront.com"
#
#   ## Authentication Token for Wavefront. Only required if using Direct Ingestion
#   #token = "DUMMY_TOKEN"
#
#   ## DNS name of the wavefront proxy server. Do not use if url is specified
#   #host = "wavefront.example.com"
#
#   ## Port that the Wavefront proxy server listens on. Do not use if url is specified
#   #port = 2878
#
#   ## prefix for metrics keys
#   #prefix = "my.specific.prefix."
#
#   ## whether to use "value" for name of simple fields. default is false
#   #simple_fields = false
#
#   ## character to use between metric and field name.  default is . (dot)
#   #metric_separator = "."
#
#   ## Convert metric name paths to use metricSeparator character
#   ## When true will convert all _ (underscore) characters in final metric name. default is true
#   #convert_paths = true
#
#   ## Use Strict rules to sanitize metric and tag names from invalid characters
#   ## When enabled forward slash (/) and comma (,) will be accepted
#   #use_strict = false
#
#   ## Use Regex to sanitize metric and tag names from invalid characters
#   ## Regex is more thorough, but significantly slower. default is false
#   #use_regex = false
#
#   ## point tags to use as the source name for Wavefront (if none found, host will be used)
#   #source_override = ["hostname", "address", "agent_host", "node_host"]
#
#   ## whether to convert boolean values to numeric values, with false -> 0.0 and true -> 1.0. default is true
#   #convert_bool = true
#
#   ## Truncate metric tags to a total of 254 characters for the tag name value. Wavefront will reject any
#   ## data point exceeding this limit if not truncated. Defaults to 'false' to provide backwards compatibility.
#   #truncate_tags = false
#
#   ## Flush the internal buffers after each batch. This effectively bypasses the background sending of metrics
#   ## normally done by the Wavefront SDK. This can be used if you are experiencing buffer overruns. The sending
#   ## of metrics will block for a longer time, but this will be handled gracefully by the internal buffering in
#   ## Telegraf.
#   #immediate_flush = true


# # Generic WebSocket output writer.
# [[outputs.websocket]]
#   ## URL is the address to send metrics to. Make sure ws or wss scheme is used.
#   url = "ws://127.0.0.1:8080/telegraf"
#
#   ## Timeouts (make sure read_timeout is larger than server ping interval or set to zero).
#   # connect_timeout = "30s"
#   # write_timeout = "30s"
#   # read_timeout = "30s"
#
#   ## Optionally turn on using text data frames (binary by default).
#   # use_text_frames = false
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Optional SOCKS5 proxy to use
#   # socks5_enabled = true
#   # socks5_address = "127.0.0.1:1080"
#   # socks5_username = "alice"
#   # socks5_password = "pass123"
#
#   ## Data format to output.
#   ## Each data format has it's own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_OUTPUT.md
#   # data_format = "influx"
#
#   ## Additional HTTP Upgrade headers
#   # [outputs.websocket.headers]
#   #   Authorization = "Bearer <TOKEN>"


# # Send aggregated metrics to Yandex.Cloud Monitoring
# [[outputs.yandex_cloud_monitoring]]
#   ## Timeout for HTTP writes.
#   # timeout = "20s"
#
#   ## Yandex.Cloud monitoring API endpoint. Normally should not be changed
#   # endpoint_url = "https://monitoring.api.cloud.yandex.net/monitoring/v2/data/write"
#
#   ## All user metrics should be sent with "custom" service specified. Normally should not be changed
#   # service = "custom"


###############################################################################
#                            PROCESSOR PLUGINS                                #
###############################################################################


# # Attach AWS EC2 metadata to metrics
# [[processors.aws_ec2]]
#   ## Instance identity document tags to attach to metrics.
#   ## For more information see:
#   ## https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html
#   ##
#   ## Available tags:
#   ## * accountId
#   ## * architecture
#   ## * availabilityZone
#   ## * billingProducts
#   ## * imageId
#   ## * instanceId
#   ## * instanceType
#   ## * kernelId
#   ## * pendingTime
#   ## * privateIp
#   ## * ramdiskId
#   ## * region
#   ## * version
#   imds_tags = []
#
#   ## EC2 instance tags retrieved with DescribeTags action.
#   ## In case tag is empty upon retrieval it's omitted when tagging metrics.
#   ## Note that in order for this to work, role attached to EC2 instance or AWS
#   ## credentials available from the environment must have a policy attached, that
#   ## allows ec2:DescribeTags.
#   ##
#   ## For more information see:
#   ## https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTags.html
#   ec2_tags = []
#
#   ## Timeout for http requests made by against aws ec2 metadata endpoint.
#   timeout = "10s"
#
#   ## ordered controls whether or not the metrics need to stay in the same order
#   ## this plugin received them in. If false, this plugin will change the order
#   ## with requests hitting cached results moving through immediately and not
#   ## waiting on slower lookups. This may cause issues for you if you are
#   ## depending on the order of metrics staying the same. If so, set this to true.
#   ## Keeping the metrics ordered may be slightly slower.
#   ordered = false
#
#   ## max_parallel_calls is the maximum number of AWS API calls to be in flight
#   ## at the same time.
#   ## It's probably best to keep this number fairly low.
#   max_parallel_calls = 10


# # Clone metrics and apply modifications.
# [[processors.clone]]
#   ## All modifications on inputs and aggregators can be overridden:
#   # name_override = "new_name"
#   # name_prefix = "new_name_prefix"
#   # name_suffix = "new_name_suffix"
#
#   ## Tags to be added (all values must be strings)
#   # [processors.clone.tags]
#   #   additional_tag = "tag_value"


# # Convert values to another metric value type
# [[processors.converter]]
#   ## Tags to convert
#   ##
#   ## The table key determines the target type, and the array of key-values
#   ## select the keys to convert.  The array may contain globs.
#   ##   <target-type> = [<tag-key>...]
#   [processors.converter.tags]
#     measurement = []
#     string = []
#     integer = []
#     unsigned = []
#     boolean = []
#     float = []
#
#   ## Fields to convert
#   ##
#   ## The table key determines the target type, and the array of key-values
#   ## select the keys to convert.  The array may contain globs.
#   ##   <target-type> = [<field-key>...]
#   [processors.converter.fields]
#     measurement = []
#     tag = []
#     string = []
#     integer = []
#     unsigned = []
#     boolean = []
#     float = []


# # Dates measurements, tags, and fields that pass through this filter.
# [[processors.date]]
# 	## New tag to create
# 	tag_key = "month"
#
# 	## New field to create (cannot set both field_key and tag_key)
# 	# field_key = "month"
#
# 	## Date format string, must be a representation of the Go "reference time"
# 	## which is "Mon Jan 2 15:04:05 -0700 MST 2006".
# 	date_format = "Jan"
#
# 	## If destination is a field, date format can also be one of
# 	## "unix", "unix_ms", "unix_us", or "unix_ns", which will insert an integer field.
# 	# date_format = "unix"
#
# 	## Offset duration added to the date string when writing the new tag.
# 	# date_offset = "0s"
#
# 	## Timezone to use when creating the tag or field using a reference time
# 	## string.  This can be set to one of "UTC", "Local", or to a location name
# 	## in the IANA Time Zone database.
# 	##   example: timezone = "America/Los_Angeles"
# 	# timezone = "UTC"


# # Filter metrics with repeating field values
# [[processors.dedup]]
#   ## Maximum time to suppress output
#   dedup_interval = "600s"


# # Defaults sets default value(s) for specified fields that are not set on incoming metrics.
# [[processors.defaults]]
#   ## Ensures a set of fields always exists on your metric(s) with their
#   ## respective default value.
#   ## For any given field pair (key = default), if it's not set, a field
#   ## is set on the metric with the specified default.
#   ##
#   ## A field is considered not set if it is nil on the incoming metric;
#   ## or it is not nil but its value is an empty string or is a string
#   ## of one or more spaces.
#   ##   <target-field> = <value>
#   # [processors.defaults.fields]
#   #   field_1 = "bar"
#   #   time_idle = 0
#   #   is_error = true


# # Map enum values according to given table.
# [[processors.enum]]
#   [[processors.enum.mapping]]
#     ## Name of the field to map. Globs accepted.
#     field = "status"
#
#     ## Name of the tag to map. Globs accepted.
#     # tag = "status"
#
#     ## Destination tag or field to be used for the mapped value.  By default the
#     ## source tag or field is used, overwriting the original value.
#     dest = "status_code"
#
#     ## Default value to be used for all values not contained in the mapping
#     ## table.  When unset, the unmodified value for the field will be used if no
#     ## match is found.
#     # default = 0
#
#     ## Table of mappings
#     [processors.enum.mapping.value_mappings]
#       green = 1
#       amber = 2
#       red = 3


# # Run executable as long-running processor plugin
# [[processors.execd]]
# 	## Program to run as daemon
# 	## eg: command = ["/path/to/your_program", "arg1", "arg2"]
# 	command = ["cat"]
#
#   ## Delay before the process is restarted after an unexpected termination
#   restart_delay = "10s"


# # Performs file path manipulations on tags and fields
# [[processors.filepath]]
#   ## Treat the tag value as a path and convert it to its last element, storing the result in a new tag
#   # [[processors.filepath.basename]]
#   #   tag = "path"
#   #   dest = "basepath"
#
#   ## Treat the field value as a path and keep all but the last element of path, typically the path's directory
#   # [[processors.filepath.dirname]]
#   #   field = "path"
#
#   ## Treat the tag value as a path, converting it to its the last element without its suffix
#   # [[processors.filepath.stem]]
#   #   tag = "path"
#
#   ## Treat the tag value as a path, converting it to the shortest path name equivalent
#   ## to path by purely lexical processing
#   # [[processors.filepath.clean]]
#   #   tag = "path"
#
#   ## Treat the tag value as a path, converting it to a relative path that is lexically
#   ## equivalent to the source path when joined to 'base_path'
#   # [[processors.filepath.rel]]
#   #   tag = "path"
#   #   base_path = "/var/log"
#
#   ## Treat the tag value as a path, replacing each separator character in path with a '/' character. Has only
#   ## effect on Windows
#   # [[processors.filepath.toslash]]
#   #   tag = "path"


# # Add a tag of the network interface name looked up over SNMP by interface number
# [[processors.ifname]]
#   ## Name of tag holding the interface number
#   # tag = "ifIndex"
#
#   ## Name of output tag where service name will be added
#   # dest = "ifName"
#
#   ## Name of tag of the SNMP agent to request the interface name from
#   # agent = "agent"
#
#   ## Timeout for each request.
#   # timeout = "5s"
#
#   ## SNMP version; can be 1, 2, or 3.
#   # version = 2
#
#   ## SNMP community string.
#   # community = "public"
#
#   ## Number of retries to attempt.
#   # retries = 3
#
#   ## The GETBULK max-repetitions parameter.
#   # max_repetitions = 10
#
#   ## SNMPv3 authentication and encryption options.
#   ##
#   ## Security Name.
#   # sec_name = "myuser"
#   ## Authentication protocol; one of "MD5", "SHA", or "".
#   # auth_protocol = "MD5"
#   ## Authentication password.
#   # auth_password = "pass"
#   ## Security Level; one of "noAuthNoPriv", "authNoPriv", or "authPriv".
#   # sec_level = "authNoPriv"
#   ## Context Name.
#   # context_name = ""
#   ## Privacy protocol used for encrypted messages; one of "DES", "AES" or "".
#   # priv_protocol = ""
#   ## Privacy password used for encrypted messages.
#   # priv_password = ""
#
#   ## max_parallel_lookups is the maximum number of SNMP requests to
#   ## make at the same time.
#   # max_parallel_lookups = 100
#
#   ## ordered controls whether or not the metrics need to stay in the
#   ## same order this plugin received them in. If false, this plugin
#   ## may change the order when data is cached.  If you need metrics to
#   ## stay in order set this to true.  keeping the metrics ordered may
#   ## be slightly slower
#   # ordered = false
#
#   ## cache_ttl is the amount of time interface names are cached for a
#   ## given agent.  After this period elapses if names are needed they
#   ## will be retrieved again.
#   # cache_ttl = "8h"


# # Adds noise to numerical fields
# [[processors.noise]]
#     ## Specified the type of the random distribution.
#     ## Can be "laplacian", "gaussian" or "uniform".
#     # type = "laplacian
#
#     ## Center of the distribution.
#     ## Only used for Laplacian and Gaussian distributions.
#     # mu = 0.0
#
#     ## Scale parameter for the Laplacian or Gaussian distribution
#     # scale = 1.0
#
#     ## Upper and lower bound of the Uniform distribution
#     # min = -1.0
#     # max = 1.0
#
#     ## Apply the noise only to numeric fields matching the filter criteria below.
#     ## Excludes takes precedence over includes.
#     # include_fields = []
#     # exclude_fields = []


# # Apply metric modifications using override semantics.
# [[processors.override]]
#   ## All modifications on inputs and aggregators can be overridden:
#   # name_override = "new_name"
#   # name_prefix = "new_name_prefix"
#   # name_suffix = "new_name_suffix"
#
#   ## Tags to be added (all values must be strings)
#   # [processors.override.tags]
#   #   additional_tag = "tag_value"


# # Parse a value in a specified field/tag(s) and add the result in a new metric
# [[processors.parser]]
#   ## The name of the fields whose value will be parsed.
#   parse_fields = []
#
#   ## If true, incoming metrics are not emitted.
#   drop_original = false
#
#   ## If set to override, emitted metrics will be merged by overriding the
#   ## original metric using the newly parsed metrics.
#   merge = "override"
#
#   ## The dataformat to be read from files
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"


# # Rotate a single valued metric into a multi field metric
# [[processors.pivot]]
#   ## Tag to use for naming the new field.
#   tag_key = "name"
#   ## Field to use as the value of the new field.
#   value_key = "value"


# # Given a tag/field of a TCP or UDP port number, add a tag/field of the service name looked up in the system services file
# [[processors.port_name]]
# [[processors.port_name]]
#   ## Name of tag holding the port number
#   # tag = "port"
#   ## Or name of the field holding the port number
#   # field = "port"
#
#   ## Name of output tag or field (depending on the source) where service name will be added
#   # dest = "service"
#
#   ## Default tcp or udp
#   # default_protocol = "tcp"
#
#   ## Tag containing the protocol (tcp or udp, case-insensitive)
#   # protocol_tag = "proto"
#
#   ## Field containing the protocol (tcp or udp, case-insensitive)
#   # protocol_field = "proto"


# # Print all metrics that pass through this filter.
# [[processors.printer]]


# # Transforms tag and field values as well as measurement, tag and field names with regex pattern
# [[processors.regex]]
#   ## Tag and field conversions defined in a separate sub-tables
#   # [[processors.regex.tags]]
#   #   ## Tag to change
#   #   key = "resp_code"
#   #   ## Regular expression to match on a tag value
#   #   pattern = "^(\\d)\\d\\d$"
#   #   ## Matches of the pattern will be replaced with this string.  Use ${1}
#   #   ## notation to use the text of the first submatch.
#   #   replacement = "${1}xx"
#
#   # [[processors.regex.fields]]
#   #   ## Field to change
#   #   key = "request"
#   #   ## All the power of the Go regular expressions available here
#   #   ## For example, named subgroups
#   #   pattern = "^/api(?P<method>/[\\w/]+)\\S*"
#   #   replacement = "${method}"
#   #   ## If result_key is present, a new field will be created
#   #   ## instead of changing existing field
#   #   result_key = "method"
#
#   ## Multiple conversions may be applied for one field sequentially
#   ## Let's extract one more value
#   # [[processors.regex.fields]]
#   #   key = "request"
#   #   pattern = ".*category=(\\w+).*"
#   #   replacement = "${1}"
#   #   result_key = "search_category"
#
#   ## Rename metric fields
#   # [[processors.regex.field_rename]]
#   #   ## Regular expression to match on a field name
#   #   pattern = "^search_(\\w+)d$"
#   #   ## Matches of the pattern will be replaced with this string.  Use ${1}
#   #   ## notation to use the text of the first submatch.
#   #   replacement = "${1}"
#   #   ## If the new field name already exists, you can either "overwrite" the
#   #   ## existing one with the value of the renamed field OR you can "keep"
#   #   ## both the existing and source field.
#   #   # result_key = "keep"
#
#   ## Rename metric tags
#   # [[processors.regex.tag_rename]]
#   #   ## Regular expression to match on a tag name
#   #   pattern = "^search_(\\w+)d$"
#   #   ## Matches of the pattern will be replaced with this string.  Use ${1}
#   #   ## notation to use the text of the first submatch.
#   #   replacement = "${1}"
#   #   ## If the new tag name already exists, you can either "overwrite" the
#   #   ## existing one with the value of the renamed tag OR you can "keep"
#   #   ## both the existing and source tag.
#   #   # result_key = "keep"
#
#   ## Rename metrics
#   # [[processors.regex.metric_rename]]
#   #   ## Regular expression to match on an metric name
#   #   pattern = "^search_(\\w+)d$"
#   #   ## Matches of the pattern will be replaced with this string.  Use ${1}
#   #   ## notation to use the text of the first submatch.
#   #   replacement = "${1}"


# # Rename measurements, tags, and fields that pass through this filter.
# [[processors.rename]]


# # ReverseDNS does a reverse lookup on IP addresses to retrieve the DNS name
# [[processors.reverse_dns]]
#   ## For optimal performance, you may want to limit which metrics are passed to this
#   ## processor. eg:
#   ## namepass = ["my_metric_*"]
#
#   ## cache_ttl is how long the dns entries should stay cached for.
#   ## generally longer is better, but if you expect a large number of diverse lookups
#   ## you'll want to consider memory use.
#   cache_ttl = "24h"
#
#   ## lookup_timeout is how long should you wait for a single dns request to repsond.
#   ## this is also the maximum acceptable latency for a metric travelling through
#   ## the reverse_dns processor. After lookup_timeout is exceeded, a metric will
#   ## be passed on unaltered.
#   ## multiple simultaneous resolution requests for the same IP will only make a
#   ## single rDNS request, and they will all wait for the answer for this long.
#   lookup_timeout = "3s"
#
#   ## max_parallel_lookups is the maximum number of dns requests to be in flight
#   ## at the same time. Requesting hitting cached values do not count against this
#   ## total, and neither do mulptiple requests for the same IP.
#   ## It's probably best to keep this number fairly low.
#   max_parallel_lookups = 10
#
#   ## ordered controls whether or not the metrics need to stay in the same order
#   ## this plugin received them in. If false, this plugin will change the order
#   ## with requests hitting cached results moving through immediately and not
#   ## waiting on slower lookups. This may cause issues for you if you are
#   ## depending on the order of metrics staying the same. If so, set this to true.
#   ## keeping the metrics ordered may be slightly slower.
#   ordered = false
#
#   [[processors.reverse_dns.lookup]]
#     ## get the ip from the field "source_ip", and put the result in the field "source_name"
#     field = "source_ip"
#     dest = "source_name"
#
#   [[processors.reverse_dns.lookup]]
#     ## get the ip from the tag "destination_ip", and put the result in the tag
#     ## "destination_name".
#     tag = "destination_ip"
#     dest = "destination_name"
#
#     ## If you would prefer destination_name to be a field instead, you can use a
#     ## processors.converter after this one, specifying the order attribute.


# # Add the S2 Cell ID as a tag based on latitude and longitude fields
# [[processors.s2geo]]
#   ## The name of the lat and lon fields containing WGS-84 latitude and
#   ## longitude in decimal degrees.
#   # lat_field = "lat"
#   # lon_field = "lon"
#
#   ## New tag to create
#   # tag_key = "s2_cell_id"
#
#   ## Cell level (see https://s2geometry.io/resources/s2cell_statistics.html)
#   # cell_level = 9


# # Process metrics using a Starlark script
# [[processors.starlark]]
#   ## The Starlark source can be set as a string in this configuration file, or
#   ## by referencing a file containing the script.  Only one source or script
#   ## should be set at once.
#   ##
#   ## Source of the Starlark script.
#   source = '''
# def apply(metric):
# 	return metric
# '''
#
#   ## File containing a Starlark script.
#   # script = "/usr/local/bin/myscript.star"
#
#   ## The constants of the Starlark script.
#   # [processors.starlark.constants]
#   #   max_size = 10
#   #   threshold = 0.75
#   #   default_name = "Julia"
#   #   debug_mode = true


# # Perform string processing on tags, fields, and measurements
# [[processors.strings]]
#   ## Convert a tag value to uppercase
#   # [[processors.strings.uppercase]]
#   #   tag = "method"
#
#   ## Convert a field value to lowercase and store in a new field
#   # [[processors.strings.lowercase]]
#   #   field = "uri_stem"
#   #   dest = "uri_stem_normalised"
#
#   ## Convert a field value to titlecase
#   # [[processors.strings.titlecase]]
#   #   field = "status"
#
#   ## Trim leading and trailing whitespace using the default cutset
#   # [[processors.strings.trim]]
#   #   field = "message"
#
#   ## Trim leading characters in cutset
#   # [[processors.strings.trim_left]]
#   #   field = "message"
#   #   cutset = "\t"
#
#   ## Trim trailing characters in cutset
#   # [[processors.strings.trim_right]]
#   #   field = "message"
#   #   cutset = "\r\n"
#
#   ## Trim the given prefix from the field
#   # [[processors.strings.trim_prefix]]
#   #   field = "my_value"
#   #   prefix = "my_"
#
#   ## Trim the given suffix from the field
#   # [[processors.strings.trim_suffix]]
#   #   field = "read_count"
#   #   suffix = "_count"
#
#   ## Replace all non-overlapping instances of old with new
#   # [[processors.strings.replace]]
#   #   measurement = "*"
#   #   old = ":"
#   #   new = "_"
#
#   ## Trims strings based on width
#   # [[processors.strings.left]]
#   #   field = "message"
#   #   width = 10
#
#   ## Decode a base64 encoded utf-8 string
#   # [[processors.strings.base64decode]]
#   #   field = "message"
#
#   ## Sanitize a string to ensure it is a valid utf-8 string
#   ## Each run of invalid UTF-8 byte sequences is replaced by the replacement string, which may be empty
#   # [[processors.strings.valid_utf8]]
#   #   field = "message"
#   #   replacement = ""


# # Restricts the number of tags that can pass through this filter and chooses which tags to preserve when over the limit.
# [[processors.tag_limit]]
#   ## Maximum number of tags to preserve
#   limit = 10
#
#   ## List of tags to preferentially preserve
#   keep = ["foo", "bar", "baz"]


# # Uses a Go template to create a new tag
# [[processors.template]]
#   ## Tag to set with the output of the template.
#   tag = "topic"
#
#   ## Go template used to create the tag value.  In order to ease TOML
#   ## escaping requirements, you may wish to use single quotes around the
#   ## template string.
#   template = '{{ .Tag "hostname" }}.{{ .Tag "level" }}'


# # Print all metrics that pass through this filter.
# [[processors.topk]]
#   ## How many seconds between aggregations
#   # period = 10
#
#   ## How many top buckets to return per field
#   ## Every field specified to aggregate over will return k number of results.
#   ## For example, 1 field with k of 10 will return 10 buckets. While 2 fields
#   ## with k of 3 will return 6 buckets.
#   # k = 10
#
#   ## Over which tags should the aggregation be done. Globs can be specified, in
#   ## which case any tag matching the glob will aggregated over. If set to an
#   ## empty list is no aggregation over tags is done
#   # group_by = ['*']
#
#   ## The field(s) to aggregate
#   ## Each field defined is used to create an independent aggregation. Each
#   ## aggregation will return k buckets. If a metric does not have a defined
#   ## field the metric will be dropped from the aggregation. Considering using
#   ## the defaults processor plugin to ensure fields are set if required.
#   # fields = ["value"]
#
#   ## What aggregation to use. Options: sum, mean, min, max
#   # aggregation = "mean"
#
#   ## Instead of the top k largest metrics, return the bottom k lowest metrics
#   # bottomk = false
#
#   ## The plugin assigns each metric a GroupBy tag generated from its name and
#   ## tags. If this setting is different than "" the plugin will add a
#   ## tag (which name will be the value of this setting) to each metric with
#   ## the value of the calculated GroupBy tag. Useful for debugging
#   # add_groupby_tag = ""
#
#   ## These settings provide a way to know the position of each metric in
#   ## the top k. The 'add_rank_field' setting allows to specify for which
#   ## fields the position is required. If the list is non empty, then a field
#   ## will be added to each and every metric for each string present in this
#   ## setting. This field will contain the ranking of the group that
#   ## the metric belonged to when aggregated over that field.
#   ## The name of the field will be set to the name of the aggregation field,
#   ## suffixed with the string '_topk_rank'
#   # add_rank_fields = []
#
#   ## These settings provide a way to know what values the plugin is generating
#   ## when aggregating metrics. The 'add_aggregate_field' setting allows to
#   ## specify for which fields the final aggregation value is required. If the
#   ## list is non empty, then a field will be added to each every metric for
#   ## each field present in this setting. This field will contain
#   ## the computed aggregation for the group that the metric belonged to when
#   ## aggregated over that field.
#   ## The name of the field will be set to the name of the aggregation field,
#   ## suffixed with the string '_topk_aggregate'
#   # add_aggregate_fields = []


# # Rotate multi field metric into several single field metrics
# [[processors.unpivot]]
#   ## Tag to use for the name.
#   tag_key = "name"
#   ## Field to use for the name of the value.
#   value_key = "value"


###############################################################################
#                            AGGREGATOR PLUGINS                               #
###############################################################################


# # Keep the aggregate basicstats of each metric passing through.
# [[aggregators.basicstats]]
#   ## The period on which to flush & clear the aggregator.
#   period = "30s"
#
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false
#
#   ## Configures which basic stats to push as fields
#   # stats = ["count", "min", "max", "mean", "stdev", "s2", "sum"]


# # Calculates a derivative for every field.
# [[aggregators.derivative]]
# 	## The period in which to flush the aggregator.
# 	period = "30s"
# 	##
# 	## If true, the original metric will be dropped by the
# 	## aggregator and will not get sent to the output plugins.
# 	drop_original = false
# 	##
# 	## This aggregator will estimate a derivative for each field, which is
# 	## contained in both the first and last metric of the aggregation interval.
# 	## Without further configuration the derivative will be calculated with
# 	## respect to the time difference between these two measurements in seconds.
# 	## The formula applied is for every field:
# 	##
# 	##               value_last - value_first
# 	## derivative = --------------------------
# 	##              time_difference_in_seconds
# 	##
# 	## The resulting derivative will be named *fieldname_rate*. The suffix
# 	## "_rate" can be configured by the *suffix* parameter. When using a
# 	## derivation variable you can include its name for more clarity.
# 	# suffix = "_rate"
# 	##
# 	## As an abstraction the derivative can be calculated not only by the time
# 	## difference but by the difference of a field, which is contained in the
# 	## measurement. This field is assumed to be monotonously increasing. This
# 	## feature is used by specifying a *variable*.
# 	## Make sure the specified variable is not filtered and exists in the metrics
# 	## passed to this aggregator!
# 	# variable = ""
# 	##
# 	## When using a field as the derivation parameter the name of that field will
# 	## be used for the resulting derivative, e.g. *fieldname_by_parameter*.
# 	##
# 	## Note, that the calculation is based on the actual timestamp of the
# 	## measurements. When there is only one measurement during that period, the
# 	## measurement will be rolled over to the next period. The maximum number of
# 	## such roll-overs can be configured with a default of 10.
# 	# max_roll_over = 10
# 	##


# # Report the final metric of a series
# [[aggregators.final]]
#   ## The period on which to flush & clear the aggregator.
#   period = "30s"
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false
#
#   ## The time that a series is not updated until considering it final.
#   series_timeout = "5m"


# # Create aggregate histograms.
# [[aggregators.histogram]]
#   ## The period in which to flush the aggregator.
#   period = "30s"
#
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false
#
#   ## If true, the histogram will be reset on flush instead
#   ## of accumulating the results.
#   reset = false
#
#   ## Whether bucket values should be accumulated. If set to false, "gt" tag will be added.
#   ## Defaults to true.
#   cumulative = true
#
#   ## Expiration interval for each histogram. The histogram will be expired if
#   ## there are no changes in any buckets for this time interval. 0 == no expiration.
#   # expiration_interval = "0m"
#
#   ## If true, aggregated histogram are pushed to output only if it was updated since
#   ## previous push. Defaults to false.
#   # push_only_on_update = false
#
#   ## Example config that aggregates all fields of the metric.
#   # [[aggregators.histogram.config]]
#   #   ## Right borders of buckets (with +Inf implicitly added).
#   #   buckets = [0.0, 15.6, 34.5, 49.1, 71.5, 80.5, 94.5, 100.0]
#   #   ## The name of metric.
#   #   measurement_name = "cpu"
#
#   ## Example config that aggregates only specific fields of the metric.
#   # [[aggregators.histogram.config]]
#   #   ## Right borders of buckets (with +Inf implicitly added).
#   #   buckets = [0.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0]
#   #   ## The name of metric.
#   #   measurement_name = "diskio"
#   #   ## The concrete fields of metric
#   #   fields = ["io_time", "read_time", "write_time"]


# # Merge metrics into multifield metrics by series key
# [[aggregators.merge]]
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = true


# # Keep the aggregate min/max of each metric passing through.
# [[aggregators.minmax]]
#   ## General Aggregator Arguments:
#   ## The period on which to flush & clear the aggregator.
#   period = "30s"
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false


# # Keep the aggregate quantiles of each metric passing through.
# [[aggregators.quantile]]
#   ## General Aggregator Arguments:
#   ## The period on which to flush & clear the aggregator.
#   period = "30s"
#
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false
#
#   ## Quantiles to output in the range [0,1]
#   # quantiles = [0.25, 0.5, 0.75]
#
#   ## Type of aggregation algorithm
#   ## Supported are:
#   ##  "t-digest" -- approximation using centroids, can cope with large number of samples
#   ##  "exact R7" -- exact computation also used by Excel or NumPy (Hyndman & Fan 1996 R7)
#   ##  "exact R8" -- exact computation (Hyndman & Fan 1996 R8)
#   ## NOTE: Do not use "exact" algorithms with large number of samples
#   ##       to not impair performance or memory consumption!
#   # algorithm = "t-digest"
#
#   ## Compression for approximation (t-digest). The value needs to be
#   ## greater or equal to 1.0. Smaller values will result in more
#   ## performance but less accuracy.
#   # compression = 100.0


# # Aggregate metrics using a Starlark script
# [[aggregators.starlark]]
#   ## The Starlark source can be set as a string in this configuration file, or
#   ## by referencing a file containing the script.  Only one source or script
#   ## should be set at once.
#   ##
#   ## Source of the Starlark script.
#   source = '''
# state = {}
#
# def add(metric):
#   state["last"] = metric
#
# def push():
#   return state.get("last")
#
# def reset():
#   state.clear()
# '''
#
#   ## File containing a Starlark script.
#   # script = "/usr/local/bin/myscript.star"
#
#   ## The constants of the Starlark script.
#   # [aggregators.starlark.constants]
#   #   max_size = 10
#   #   threshold = 0.75
#   #   default_name = "Julia"
#   #   debug_mode = true


# # Count the occurrence of values in fields.
# [[aggregators.valuecounter]]
#   ## General Aggregator Arguments:
#   ## The period on which to flush & clear the aggregator.
#   period = "30s"
#   ## If true, the original metric will be dropped by the
#   ## aggregator and will not get sent to the output plugins.
#   drop_original = false
#   ## The fields for which the values will be counted
#   fields = []


###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################


# Read metrics about cpu usage
[[inputs.cpu]]
  ## Whether to report per-cpu stats or not
  percpu = true
  ## Whether to report total system cpu stats or not
  totalcpu = true
  ## If true, collect raw CPU time metrics
  collect_cpu_time = false
  ## If true, compute and report the sum of all non-idle CPU states
  report_active = false


# Read metrics about disk usage by mount point
[[inputs.disk]]
  ## By default stats will be gathered for all mount points.
  ## Set mount_points will restrict the stats to only the specified mount points.
  # mount_points = ["/"]

  ## Ignore mount points by filesystem type.
  ignore_fs = ["tmpfs", "devtmpfs", "devfs", "iso9660", "overlay", "aufs", "squashfs"]


# Read metrics about disk IO by device
[[inputs.diskio]]
  ## By default, telegraf will gather stats for all devices including
  ## disk partitions.
  ## Setting devices will restrict the stats to the specified devices.
  # devices = ["sda", "sdb", "vd*"]
  ## Uncomment the following line if you need disk serial numbers.
  # skip_serial_number = false
  #
  ## On systems which support it, device metadata can be added in the form of
  ## tags.
  ## Currently only Linux is supported via udev properties. You can view
  ## available properties for a device by running:
  ## 'udevadm info -q property -n /dev/sda'
  ## Note: Most, but not all, udev properties can be accessed this way. Properties
  ## that are currently inaccessible include DEVTYPE, DEVNAME, and DEVPATH.
  # device_tags = ["ID_FS_TYPE", "ID_FS_USAGE"]
  #
  ## Using the same metadata source as device_tags, you can also customize the
  ## name of the device via templates.
  ## The 'name_templates' parameter is a list of templates to try and apply to
  ## the device. The template may contain variables in the form of '$PROPERTY' or
  ## '${PROPERTY}'. The first template which does not contain any variables not
  ## present for the device is used as the device name tag.
  ## The typical use case is for LVM volumes, to get the VG/LV name instead of
  ## the near-meaningless DM-0 name.
  # name_templates = ["$ID_FS_LABEL","$DM_VG_NAME/$DM_LV_NAME"]


# Get kernel statistics from /proc/stat
[[inputs.kernel]]
  # no configuration


# Read metrics about memory usage
[[inputs.mem]]
  # no configuration


# Get the number of processes and group them by status
# [[inputs.processes]]
  # no configuration


# Read metrics about swap memory usage
[[inputs.swap]]
  # no configuration


# Read metrics about system load & uptime
[[inputs.system]]
  ## Uncomment to remove deprecated metrics.
  fielddrop = ["uptime_format"]


# # Gather ActiveMQ metrics
# [[inputs.activemq]]
#   ## ActiveMQ WebConsole URL
#   url = "http://127.0.0.1:8161"
#
#   ## Credentials for basic HTTP authentication
#   # username = "admin"
#   # password = "admin"
#
#   ## Required ActiveMQ webadmin root path
#   # webadmin = "admin"
#
#   ## Maximum time to receive response.
#   # response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read stats from aerospike server(s)
# [[inputs.aerospike]]
#   ## Aerospike servers to connect to (with port)
#   ## This plugin will query all namespaces the aerospike
#   ## server has configured and get stats for them.
#   servers = ["localhost:3000"]
#
#   # username = "telegraf"
#   # password = "pa$$word"
#
#   ## Optional TLS Config
#   # enable_tls = false
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   # tls_name = "tlsname"
#   ## If false, skip chain & host verification
#   # insecure_skip_verify = true
#
#   # Feature Options
#   # Add namespace variable to limit the namespaces executed on
#   # Leave blank to do all
#   # disable_query_namespaces = true # default false
#   # namespaces = ["namespace1", "namespace2"]
#
#   # Enable set level telemetry
#   # query_sets = true # default: false
#   # Add namespace set combinations to limit sets executed on
#   # Leave blank to do all sets
#   # sets = ["namespace1/set1", "namespace1/set2", "namespace3"]
#
#   # Histograms
#   # enable_ttl_histogram = true # default: false
#   # enable_object_size_linear_histogram = true # default: false
#
#   # by default, aerospike produces a 100 bucket histogram
#   # this is not great for most graphing tools, this will allow
#   # the ability to squash this to a smaller number of buckets
#   # To have a balanced histogram, the number of buckets chosen
#   # should divide evenly into 100.
#   # num_histogram_buckets = 100 # default: 10


# # Query statistics from AMD Graphics cards using rocm-smi binary
# [[inputs.amd_rocm_smi]]
# ## Optional: path to rocm-smi binary, defaults to $PATH via exec.LookPath
# # bin_path = "/opt/rocm/bin/rocm-smi"
#
# ## Optional: timeout for GPU polling
# # timeout = "5s"


# # Read Apache status information (mod_status)
# [[inputs.apache]]
#   ## An array of URLs to gather from, must be directed at the machine
#   ## readable version of the mod_status page including the auto query string.
#   ## Default is "http://localhost/server-status?auto".
#   urls = ["http://localhost/server-status?auto"]
#
#   ## Credentials for basic HTTP authentication.
#   # username = "myuser"
#   # password = "mypassword"
#
#   ## Maximum time to receive response.
#   # response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Monitor APC UPSes connected to apcupsd
# [[inputs.apcupsd]]
#   # A list of running apcupsd server to connect to.
#   # If not provided will default to tcp://127.0.0.1:3551
#   servers = ["tcp://127.0.0.1:3551"]
#
#   ## Timeout for dialing server.
#   timeout = "5s"


# # Gather metrics from Apache Aurora schedulers
# [[inputs.aurora]]
#   ## Schedulers are the base addresses of your Aurora Schedulers
#   schedulers = ["http://127.0.0.1:8081"]
#
#   ## Set of role types to collect metrics from.
#   ##
#   ## The scheduler roles are checked each interval by contacting the
#   ## scheduler nodes; zookeeper is not contacted.
#   # roles = ["leader", "follower"]
#
#   ## Timeout is the max time for total network operations.
#   # timeout = "5s"
#
#   ## Username and password are sent using HTTP Basic Auth.
#   # username = "username"
#   # password = "pa$$word"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Gather Azure Storage Queue metrics
# [[inputs.azure_storage_queue]]
#   ## Required Azure Storage Account name
#   account_name = "mystorageaccount"
#
#   ## Required Azure Storage Account access key
#   account_key = "storageaccountaccesskey"
#
#   ## Set to false to disable peeking age of oldest message (executes faster)
#   # peek_oldest_message_age = true


# # Read metrics of bcache from stats_total and dirty_data
# [[inputs.bcache]]
#   ## Bcache sets path
#   ## If not specified, then default is:
#   bcachePath = "/sys/fs/bcache"
#
#   ## By default, Telegraf gather stats for all bcache devices
#   ## Setting devices will restrict the stats to the specified
#   ## bcache devices.
#   bcacheDevs = ["bcache0"]


# # Collects Beanstalkd server and tubes stats
# [[inputs.beanstalkd]]
#   ## Server to collect data from
#   server = "localhost:11300"
#
#   ## List of tubes to gather stats about.
#   ## If no tubes specified then data gathered for each tube on server reported by list-tubes command
#   tubes = ["notifications"]


# # Read metrics exposed by Beat
# [[inputs.beat]]
#   ## An URL from which to read Beat-formatted JSON
#   ## Default is "http://127.0.0.1:5066".
#   url = "http://127.0.0.1:5066"
#
#   ## Enable collection of the listed stats
#   ## An empty list means collect all. Available options are currently
#   ## "beat", "libbeat", "system" and "filebeat".
#   # include = ["beat", "libbeat", "filebeat"]
#
#   ## HTTP method
#   # method = "GET"
#
#   ## Optional HTTP headers
#   # headers = {"X-Special-Header" = "Special-Value"}
#
#   ## Override HTTP "Host" header
#   # host_header = "logstash.example.com"
#
#   ## Timeout for HTTP requests
#   # timeout = "5s"
#
#   ## Optional HTTP Basic Auth credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read BIND nameserver XML statistics
# [[inputs.bind]]
#   ## An array of BIND XML statistics URI to gather stats.
#   ## Default is "http://localhost:8053/xml/v3".
#   # urls = ["http://localhost:8053/xml/v3"]
#   # gather_memory_contexts = false
#   # gather_views = false
#
#   ## Timeout for http requests made by bind nameserver
#   # timeout = "4s"


# # Collect bond interface status, slaves statuses and failures count
# [[inputs.bond]]
#   ## Sets 'proc' directory path
#   ## If not specified, then default is /proc
#   # host_proc = "/proc"
#
#   ## Sets 'sys' directory path
#   ## If not specified, then default is /sys
#   # host_sys = "/sys"
#
#   ## By default, telegraf gather stats for all bond interfaces
#   ## Setting interfaces will restrict the stats to the specified
#   ## bond interfaces.
#   # bond_interfaces = ["bond0"]
#
#   ## Tries to collect additional bond details from /sys/class/net/{bond}
#   ## currently only useful for LACP (mode 4) bonds
#   # collect_sys_details = false
#


# # Collect Kafka topics and consumers status from Burrow HTTP API.
# [[inputs.burrow]]
#   ## Burrow API endpoints in format "schema://host:port".
#   ## Default is "http://localhost:8000".
#   servers = ["http://localhost:8000"]
#
#   ## Override Burrow API prefix.
#   ## Useful when Burrow is behind reverse-proxy.
#   # api_prefix = "/v3/kafka"
#
#   ## Maximum time to receive response.
#   # response_timeout = "5s"
#
#   ## Limit per-server concurrent connections.
#   ## Useful in case of large number of topics or consumer groups.
#   # concurrent_connections = 20
#
#   ## Filter clusters, default is no filtering.
#   ## Values can be specified as glob patterns.
#   # clusters_include = []
#   # clusters_exclude = []
#
#   ## Filter consumer groups, default is no filtering.
#   ## Values can be specified as glob patterns.
#   # groups_include = []
#   # groups_exclude = []
#
#   ## Filter topics, default is no filtering.
#   ## Values can be specified as glob patterns.
#   # topics_include = []
#   # topics_exclude = []
#
#   ## Credentials for basic HTTP authentication.
#   # username = ""
#   # password = ""
#
#   ## Optional SSL config
#   # ssl_ca = "/etc/telegraf/ca.pem"
#   # ssl_cert = "/etc/telegraf/cert.pem"
#   # ssl_key = "/etc/telegraf/key.pem"
#   # insecure_skip_verify = false


# # Collects performance metrics from the MON, OSD, MDS and RGW nodes in a Ceph storage cluster.
# [[inputs.ceph]]
#   ## This is the recommended interval to poll.  Too frequent and you will lose
#   ## data points due to timeouts during rebalancing and recovery
#   interval = '1m'
#
#   ## All configuration values are optional, defaults are shown below
#
#   ## location of ceph binary
#   ceph_binary = "/usr/bin/ceph"
#
#   ## directory in which to look for socket files
#   socket_dir = "/var/run/ceph"
#
#   ## prefix of MON and OSD socket files, used to determine socket type
#   mon_prefix = "ceph-mon"
#   osd_prefix = "ceph-osd"
#   mds_prefix = "ceph-mds"
#   rgw_prefix = "ceph-client"
#
#   ## suffix used to identify socket files
#   socket_suffix = "asok"
#
#   ## Ceph user to authenticate as, ceph will search for the corresponding keyring
#   ## e.g. client.admin.keyring in /etc/ceph, or the explicit path defined in the
#   ## client section of ceph.conf for example:
#   ##
#   ##     [client.telegraf]
#   ##         keyring = /etc/ceph/client.telegraf.keyring
#   ##
#   ## Consult the ceph documentation for more detail on keyring generation.
#   ceph_user = "client.admin"
#
#   ## Ceph configuration to use to locate the cluster
#   ceph_config = "/etc/ceph/ceph.conf"
#
#   ## Whether to gather statistics via the admin socket
#   gather_admin_socket_stats = true
#
#   ## Whether to gather statistics via ceph commands, requires ceph_user and ceph_config
#   ## to be specified
#   gather_cluster_stats = false


# # Read specific statistics per cgroup
# [[inputs.cgroup]]
#   ## Directories in which to look for files, globs are supported.
#   ## Consider restricting paths to the set of cgroups you really
#   ## want to monitor if you have a large number of cgroups, to avoid
#   ## any cardinality issues.
#   # paths = [
#   #   "/sys/fs/cgroup/memory",
#   #   "/sys/fs/cgroup/memory/child1",
#   #   "/sys/fs/cgroup/memory/child2/*",
#   # ]
#   ## cgroup stat fields, as file names, globs are supported.
#   ## these file names are appended to each path from above.
#   # files = ["memory.*usage*", "memory.limit_in_bytes"]


# # Get standard chrony metrics, requires chronyc executable.
# [[inputs.chrony]]
#   ## If true, chronyc tries to perform a DNS lookup for the time server.
#   # dns_lookup = false


# # Pull Metric Statistics from Amazon CloudWatch
# [[inputs.cloudwatch]]
#   ## Amazon Region
#   region = "us-east-1"
#
#   ## Amazon Credentials
#   ## Credentials are loaded in the following order
#   ## 1) Web identity provider credentials via STS if role_arn and web_identity_token_file are specified
#   ## 2) Assumed credentials via STS if role_arn is specified
#   ## 3) explicit credentials from 'access_key' and 'secret_key'
#   ## 4) shared profile from 'profile'
#   ## 5) environment variables
#   ## 6) shared credentials file
#   ## 7) EC2 Instance Profile
#   # access_key = ""
#   # secret_key = ""
#   # token = ""
#   # role_arn = ""
#   # web_identity_token_file = ""
#   # role_session_name = ""
#   # profile = ""
#   # shared_credential_file = ""
#
#   ## Endpoint to make request against, the correct endpoint is automatically
#   ## determined and this option should only be set if you wish to override the
#   ## default.
#   ##   ex: endpoint_url = "http://localhost:8000"
#   # endpoint_url = ""
#
#   ## Set http_proxy (telegraf uses the system wide proxy settings if it's is not set)
#   # http_proxy_url = "http://localhost:8888"
#
#   # The minimum period for Cloudwatch metrics is 1 minute (60s). However not all
#   # metrics are made available to the 1 minute period. Some are collected at
#   # 3 minute, 5 minute, or larger intervals. See https://aws.amazon.com/cloudwatch/faqs/#monitoring.
#   # Note that if a period is configured that is smaller than the minimum for a
#   # particular metric, that metric will not be returned by the Cloudwatch API
#   # and will not be collected by Telegraf.
#   #
#   ## Requested CloudWatch aggregation Period (required - must be a multiple of 60s)
#   period = "5m"
#
#   ## Collection Delay (required - must account for metrics availability via CloudWatch API)
#   delay = "5m"
#
#   ## Recommended: use metric 'interval' that is a multiple of 'period' to avoid
#   ## gaps or overlap in pulled data
#   interval = "5m"
#
#   ## Recommended if "delay" and "period" are both within 3 hours of request time. Invalid values will be ignored.
#   ## Recently Active feature will only poll for CloudWatch ListMetrics values that occurred within the last 3 Hours.
#   ## If enabled, it will reduce total API usage of the CloudWatch ListMetrics API and require less memory to retain.
#   ## Do not enable if "period" or "delay" is longer than 3 hours, as it will not return data more than 3 hours old.
#   ## See https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_ListMetrics.html
#   #recently_active = "PT3H"
#
#   ## Configure the TTL for the internal cache of metrics.
#   # cache_ttl = "1h"
#
#   ## Metric Statistic Namespaces (required)
#   namespaces = ["AWS/ELB"]
#   # A single metric statistic namespace that will be appended to namespaces on startup
#   # namespace = "AWS/ELB"
#
#   ## Maximum requests per second. Note that the global default AWS rate limit is
#   ## 50 reqs/sec, so if you define multiple namespaces, these should add up to a
#   ## maximum of 50.
#   ## See http://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_limits.html
#   # ratelimit = 25
#
#   ## Timeout for http requests made by the cloudwatch client.
#   # timeout = "5s"
#
#   ## Namespace-wide statistic filters. These allow fewer queries to be made to
#   ## cloudwatch.
#   # statistic_include = [ "average", "sum", "minimum", "maximum", sample_count" ]
#   # statistic_exclude = []
#
#   ## Metrics to Pull
#   ## Defaults to all Metrics in Namespace if nothing is provided
#   ## Refreshes Namespace available metrics every 1h
#   #[[inputs.cloudwatch.metrics]]
#   #  names = ["Latency", "RequestCount"]
#   #
#   #  ## Statistic filters for Metric.  These allow for retrieving specific
#   #  ## statistics for an individual metric.
#   #  # statistic_include = [ "average", "sum", "minimum", "maximum", sample_count" ]
#   #  # statistic_exclude = []
#   #
#   #  ## Dimension filters for Metric.  All dimensions defined for the metric names
#   #  ## must be specified in order to retrieve the metric statistics.
#   #  ## 'value' has wildcard / 'glob' matching support such as 'p-*'.
#   #  [[inputs.cloudwatch.metrics.dimensions]]
#   #    name = "LoadBalancerName"
#   #    value = "p-example"


# # Collects conntrack stats from the configured directories and files.
# [[inputs.conntrack]]
#    ## The following defaults would work with multiple versions of conntrack.
#    ## Note the nf_ and ip_ filename prefixes are mutually exclusive across
#    ## kernel versions, as are the directory locations.
#
#    ## Superset of filenames to look for within the conntrack dirs.
#    ## Missing files will be ignored.
#    files = ["ip_conntrack_count","ip_conntrack_max",
#             "nf_conntrack_count","nf_conntrack_max"]
#
#    ## Directories to search within for the conntrack files above.
#    ## Missing directories will be ignored.
#    dirs = ["/proc/sys/net/ipv4/netfilter","/proc/sys/net/netfilter"]


# # Gather health check statuses from services registered in Consul
# [[inputs.consul]]
#   ## Consul server address
#   # address = "localhost:8500"
#
#   ## URI scheme for the Consul server, one of "http", "https"
#   # scheme = "http"
#
#   ## Metric version controls the mapping from Consul metrics into
#   ## Telegraf metrics.
#   ##
#   ##   example: metric_version = 1; deprecated in 1.15
#   ##            metric_version = 2; recommended version
#   # metric_version = 1
#
#   ## ACL token used in every request
#   # token = ""
#
#   ## HTTP Basic Authentication username and password.
#   # username = ""
#   # password = ""
#
#   ## Data center to query the health checks from
#   # datacenter = ""
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = true
#
#   ## Consul checks' tag splitting
#   # When tags are formatted like "key:value" with ":" as a delimiter then
#   # they will be splitted and reported as proper key:value in Telegraf
#   # tag_delimiter = ":"


# # Read metrics from the Consul Agent API
# [[inputs.consul_agent]]
#   ## URL for the Consul agent
#   # url = "http://127.0.0.1:8500"
#
#   ## Use auth token for authorization.
#   ## Only one of the options can be set. Leave empty to not use any token.
#   # token_file = "/path/to/auth/token"
#   ## OR
#   # token = "a1234567-40c7-9048-7bae-378687048181"
#
#   ## Set timeout (default 5 seconds)
#   # timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = /path/to/cafile
#   # tls_cert = /path/to/certfile
#   # tls_key = /path/to/keyfile


# # Read per-node and per-bucket metrics from Couchbase
# [[inputs.couchbase]]
#   ## specify servers via a url matching:
#   ##  [protocol://][:password]@address[:port]
#   ##  e.g.
#   ##    http://couchbase-0.example.com/
#   ##    http://admin:secret@couchbase-0.example.com:8091/
#   ##
#   ## If no servers are specified, then localhost is used as the host.
#   ## If no protocol is specified, HTTP is used.
#   ## If no port is specified, 8091 is used.
#   servers = ["http://localhost:8091"]
#
#   ## Filter bucket fields to include only here.
#   # bucket_stats_included = ["quota_percent_used", "ops_per_sec", "disk_fetches", "item_count", "disk_used", "data_used", "mem_used"]
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification (defaults to false)
#   ## If set to false, tls_cert and tls_key are required
#   # insecure_skip_verify = false


# # Read CouchDB Stats from one or more servers
# [[inputs.couchdb]]
#   ## Works with CouchDB stats endpoints out of the box
#   ## Multiple Hosts from which to read CouchDB stats:
#   hosts = ["http://localhost:8086/_stats"]
#
#   ## Use HTTP Basic Authentication.
#   # basic_username = "telegraf"
#   # basic_password = "p@ssw0rd"


# # Fetch metrics from a CSGO SRCDS
# [[inputs.csgo]]
#   ## Specify servers using the following format:
#   ##    servers = [
#   ##      ["ip1:port1", "rcon_password1"],
#   ##      ["ip2:port2", "rcon_password2"],
#   ##    ]
#   #
#   ## If no servers are specified, no data will be collected
#   servers = []


# # Input plugin for DC/OS metrics
# [[inputs.dcos]]
#   ## The DC/OS cluster URL.
#   cluster_url = "https://dcos-ee-master-1"
#
#   ## The ID of the service account.
#   service_account_id = "telegraf"
#   ## The private key file for the service account.
#   service_account_private_key = "/etc/telegraf/telegraf-sa-key.pem"
#
#   ## Path containing login token.  If set, will read on every gather.
#   # token_file = "/home/dcos/.dcos/token"
#
#   ## In all filter options if both include and exclude are empty all items
#   ## will be collected.  Arrays may contain glob patterns.
#   ##
#   ## Node IDs to collect metrics from.  If a node is excluded, no metrics will
#   ## be collected for its containers or apps.
#   # node_include = []
#   # node_exclude = []
#   ## Container IDs to collect container metrics from.
#   # container_include = []
#   # container_exclude = []
#   ## Container IDs to collect app metrics from.
#   # app_include = []
#   # app_exclude = []
#
#   ## Maximum concurrent connections to the cluster.
#   # max_connections = 10
#   ## Maximum time to receive a response from cluster.
#   # response_timeout = "20s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## If false, skip chain & host verification
#   # insecure_skip_verify = true
#
#   ## Recommended filtering to reduce series cardinality.
#   # [inputs.dcos.tagdrop]
#   #   path = ["/var/lib/mesos/slave/slaves/*"]


# # Read metrics from one or many disque servers
# [[inputs.disque]]
#   ## An array of URI to gather stats about. Specify an ip or hostname
#   ## with optional port and password.
#   ## ie disque://localhost, disque://10.10.3.33:18832, 10.0.0.1:10000, etc.
#   ## If no servers are specified, then localhost is used as the host.
#   servers = ["localhost"]


# # Provide a native collection for dmsetup based statistics for dm-cache
# [[inputs.dmcache]]
#   ## Whether to report per-device stats or not
#   per_device = true


# # Query given DNS server and gives statistics
# [[inputs.dns_query]]
#   ## servers to query
#   servers = ["8.8.8.8"]
#
#   ## Network is the network protocol name.
#   # network = "udp"
#
#   ## Domains or subdomains to query.
#   # domains = ["."]
#
#   ## Query record type.
#   ## Possible values: A, AAAA, CNAME, MX, NS, PTR, TXT, SOA, SPF, SRV.
#   # record_type = "A"
#
#   ## Dns server port.
#   # port = 53
#
#   ## Query timeout in seconds.
#   # timeout = 2


# # Read metrics about docker containers
# [[inputs.docker]]
#   ## Docker Endpoint
#   ##   To use TCP, set endpoint = "tcp://[ip]:[port]"
#   ##   To use environment variables (ie, docker-machine), set endpoint = "ENV"
#   endpoint = "unix:///var/run/docker.sock"
#
#   ## Set to true to collect Swarm metrics(desired_replicas, running_replicas)
#   gather_services = false
#
#   ## Set the source tag for the metrics to the container ID hostname, eg first 12 chars
#   source_tag = false
#
#   ## Containers to include and exclude. Globs accepted.
#   ## Note that an empty array for both will include all containers
#   container_name_include = []
#   container_name_exclude = []
#
#   ## Container states to include and exclude. Globs accepted.
#   ## When empty only containers in the "running" state will be captured.
#   ## example: container_state_include = ["created", "restarting", "running", "removing", "paused", "exited", "dead"]
#   ## example: container_state_exclude = ["created", "restarting", "running", "removing", "paused", "exited", "dead"]
#   # container_state_include = []
#   # container_state_exclude = []
#
#   ## Timeout for docker list, info, and stats commands
#   timeout = "5s"
#
#   ## Specifies for which classes a per-device metric should be issued
#   ## Possible values are 'cpu' (cpu0, cpu1, ...), 'blkio' (8:0, 8:1, ...) and 'network' (eth0, eth1, ...)
#   ## Please note that this setting has no effect if 'perdevice' is set to 'true'
#   # perdevice_include = ["cpu"]
#
#   ## Specifies for which classes a total metric should be issued. Total is an aggregated of the 'perdevice' values.
#   ## Possible values are 'cpu', 'blkio' and 'network'
#   ## Total 'cpu' is reported directly by Docker daemon, and 'network' and 'blkio' totals are aggregated by this plugin.
#   ## Please note that this setting has no effect if 'total' is set to 'false'
#   # total_include = ["cpu", "blkio", "network"]
#
#   ## Which environment variables should we use as a tag
#   ##tag_env = ["JAVA_HOME", "HEAP_SIZE"]
#
#   ## docker labels to include and exclude as tags.  Globs accepted.
#   ## Note that an empty array for both will include all labels as tags
#   docker_label_include = []
#   docker_label_exclude = []
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read statistics from one or many dovecot servers
# [[inputs.dovecot]]
#   ## specify dovecot servers via an address:port list
#   ##  e.g.
#   ##    localhost:24242
#   ##
#   ## If no servers are specified, then localhost is used as the host.
#   servers = ["localhost:24242"]
#
#   ## Type is one of "user", "domain", "ip", or "global"
#   type = "global"
#
#   ## Wildcard matches like "*.com". An empty string "" is same as "*"
#   ## If type = "ip" filters should be <IP/network>
#   filters = [""]


# # Reads metrics from DPDK applications using v2 telemetry interface.
# [[inputs.dpdk]]
#   ## Path to DPDK telemetry socket. This shall point to v2 version of DPDK telemetry interface.
#   # socket_path = "/var/run/dpdk/rte/dpdk_telemetry.v2"
#
#   ## Duration that defines how long the connected socket client will wait for a response before terminating connection.
#   ## This includes both writing to and reading from socket. Since it's local socket access
#   ## to a fast packet processing application, the timeout should be sufficient for most users.
#   ## Setting the value to 0 disables the timeout (not recommended)
#   # socket_access_timeout = "200ms"
#
#   ## Enables telemetry data collection for selected device types.
#   ## Adding "ethdev" enables collection of telemetry from DPDK NICs (stats, xstats, link_status).
#   ## Adding "rawdev" enables collection of telemetry from DPDK Raw Devices (xstats).
#   # device_types = ["ethdev"]
#
#   ## List of custom, application-specific telemetry commands to query
#   ## The list of available commands depend on the application deployed. Applications can register their own commands
#   ##   via telemetry library API http://doc.dpdk.org/guides/prog_guide/telemetry_lib.html#registering-commands
#   ## For e.g. L3 Forwarding with Power Management Sample Application this could be:
#   ##   additional_commands = ["/l3fwd-power/stats"]
#   # additional_commands = []
#
#   ## Allows turning off collecting data for individual "ethdev" commands.
#   ## Remove "/ethdev/link_status" from list to start getting link status metrics.
#   [inputs.dpdk.ethdev]
#     exclude_commands = ["/ethdev/link_status"]
#
#   ## When running multiple instances of the plugin it's recommended to add a unique tag to each instance to identify
#   ## metrics exposed by an instance of DPDK application. This is useful when multiple DPDK apps run on a single host.
#   ##  [inputs.dpdk.tags]
#   ##    dpdk_instance = "my-fwd-app"


# # Read metrics about docker containers from Fargate/ECS v2, v3 meta endpoints.
# [[inputs.ecs]]
#   ## ECS metadata url.
#   ## Metadata v2 API is used if set explicitly. Otherwise,
#   ## v3 metadata endpoint API is used if available.
#   # endpoint_url = ""
#
#   ## Containers to include and exclude. Globs accepted.
#   ## Note that an empty array for both will include all containers
#   # container_name_include = []
#   # container_name_exclude = []
#
#   ## Container states to include and exclude. Globs accepted.
#   ## When empty only containers in the "RUNNING" state will be captured.
#   ## Possible values are "NONE", "PULLED", "CREATED", "RUNNING",
#   ## "RESOURCES_PROVISIONED", "STOPPED".
#   # container_status_include = []
#   # container_status_exclude = []
#
#   ## ecs labels to include and exclude as tags.  Globs accepted.
#   ## Note that an empty array for both will include all labels as tags
#   ecs_label_include = [ "com.amazonaws.ecs.*" ]
#   ecs_label_exclude = []
#
#   ## Timeout for queries.
#   # timeout = "5s"


# # Read stats from one or more Elasticsearch servers or clusters
# [[inputs.elasticsearch]]
#   ## specify a list of one or more Elasticsearch servers
#   # you can add username and password to your url to use basic authentication:
#   # servers = ["http://user:pass@localhost:9200"]
#   servers = ["http://localhost:9200"]
#
#   ## Timeout for HTTP requests to the elastic search server(s)
#   http_timeout = "5s"
#
#   ## When local is true (the default), the node will read only its own stats.
#   ## Set local to false when you want to read the node stats from all nodes
#   ## of the cluster.
#   local = true
#
#   ## Set cluster_health to true when you want to also obtain cluster health stats
#   cluster_health = false
#
#   ## Adjust cluster_health_level when you want to also obtain detailed health stats
#   ## The options are
#   ##  - indices (default)
#   ##  - cluster
#   # cluster_health_level = "indices"
#
#   ## Set cluster_stats to true when you want to also obtain cluster stats.
#   cluster_stats = false
#
#   ## Only gather cluster_stats from the master node. To work this require local = true
#   cluster_stats_only_from_master = true
#
#   ## Indices to collect; can be one or more indices names or _all
#   ## Use of wildcards is allowed. Use a wildcard at the end to retrieve index names that end with a changing value, like a date.
#   indices_include = ["_all"]
#
#   ## One of "shards", "cluster", "indices"
#   indices_level = "shards"
#
#   ## node_stats is a list of sub-stats that you want to have gathered. Valid options
#   ## are "indices", "os", "process", "jvm", "thread_pool", "fs", "transport", "http",
#   ## "breaker". Per default, all stats are gathered.
#   # node_stats = ["jvm", "http"]
#
#   ## HTTP Basic Authentication username and password.
#   # username = ""
#   # password = ""
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Sets the number of most recent indices to return for indices that are configured with a date-stamped suffix.
#   ## Each 'indices_include' entry ending with a wildcard (*) or glob matching pattern will group together all indices that match it, and sort them
#   ## by the date or number after the wildcard. Metrics then are gathered for only the 'num_most_recent_indices' amount of most recent indices.
#   # num_most_recent_indices = 0


# # Derive metrics from aggregating Elasticsearch query results
# [[inputs.elasticsearch_query]]
#   ## The full HTTP endpoint URL for your Elasticsearch instance
#   ## Multiple urls can be specified as part of the same cluster,
#   ## this means that only ONE of the urls will be written to each interval.
#   urls = [ "http://node1.es.example.com:9200" ] # required.
#
#   ## Elasticsearch client timeout, defaults to "5s".
#   # timeout = "5s"
#
#   ## Set to true to ask Elasticsearch a list of all cluster nodes,
#   ## thus it is not necessary to list all nodes in the urls config option
#   # enable_sniffer = false
#
#   ## Set the interval to check if the Elasticsearch nodes are available
#   ## This option is only used if enable_sniffer is also set (0s to disable it)
#   # health_check_interval = "10s"
#
#   ## HTTP basic authentication details (eg. when using x-pack)
#   # username = "telegraf"
#   # password = "mypassword"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   [[inputs.elasticsearch_query.aggregation]]
#     ## measurement name for the results of the aggregation query
#     measurement_name = "measurement"
#
#     ## Elasticsearch indexes to query (accept wildcards).
#     index = "index-*"
#
#     ## The date/time field in the Elasticsearch index (mandatory).
#     date_field = "@timestamp"
#
#     ## If the field used for the date/time field in Elasticsearch is also using
#     ## a custom date/time format it may be required to provide the format to
#     ## correctly parse the field.
#     ##
#     ## If using one of the built in elasticsearch formats this is not required.
#     # date_field_custom_format = ""
#
#     ## Time window to query (eg. "1m" to query documents from last minute).
#     ## Normally should be set to same as collection interval
#     query_period = "1m"
#
#     ## Lucene query to filter results
#     # filter_query = "*"
#
#     ## Fields to aggregate values (must be numeric fields)
#     # metric_fields = ["metric"]
#
#     ## Aggregation function to use on the metric fields
#     ## Must be set if 'metric_fields' is set
#     ## Valid values are: avg, sum, min, max, sum
#     # metric_function = "avg"
#
#     ## Fields to be used as tags
#     ## Must be text, non-analyzed fields. Metric aggregations are performed per tag
#     # tags = ["field.keyword", "field2.keyword"]
#
#     ## Set to true to not ignore documents when the tag(s) above are missing
#     # include_missing_tag = false
#
#     ## String value of the tag when the tag does not exist
#     ## Used when include_missing_tag is true
#     # missing_tag_value = "null"


# # Returns ethtool statistics for given interfaces
# [[inputs.ethtool]]
#   ## List of interfaces to pull metrics for
#   # interface_include = ["eth0"]
#
#   ## List of interfaces to ignore when pulling metrics.
#   # interface_exclude = ["eth1"]
#
#   ## Some drivers declare statistics with extra whitespace, different spacing,
#   ## and mix cases. This list, when enabled, can be used to clean the keys.
#   ## Here are the current possible normalizations:
#   ##  * snakecase: converts fooBarBaz to foo_bar_baz
#   ##  * trim: removes leading and trailing whitespace
#   ##  * lower: changes all capitalized letters to lowercase
#   ##  * underscore: replaces spaces with underscores
#   # normalize_keys = ["snakecase", "trim", "lower", "underscore"]


# # Read metrics from one or more commands that can output to stdout
# [[inputs.exec]]
#   ## Commands array
#   commands = [
#     "/tmp/test.sh",
#     "/usr/bin/mycollector --foo=bar",
#     "/tmp/collect_*.sh"
#   ]
#
#   ## Timeout for each command to complete.
#   timeout = "5s"
#
#   ## measurement name suffix (for separating different commands)
#   name_suffix = "_mycollector"
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"


# # Read metrics from fail2ban.
# [[inputs.fail2ban]]
#   ## Use sudo to run fail2ban-client
#   use_sudo = false


# # Read devices value(s) from a Fibaro controller
# [[inputs.fibaro]]
#   ## Required Fibaro controller address/hostname.
#   ## Note: at the time of writing this plugin, Fibaro only implemented http - no https available
#   url = "http://<controller>:80"
#
#   ## Required credentials to access the API (http://<controller/api/<component>)
#   username = "<username>"
#   password = "<password>"
#
#   ## Amount of time allowed to complete the HTTP request
#   # timeout = "5s"


# # Parse a complete file each interval
# [[inputs.file]]
#   ## Files to parse each interval.  Accept standard unix glob matching rules,
#   ## as well as ** to match recursive files and directories.
#   files = ["/tmp/metrics.out"]
#
#
#   ## Name a tag containing the name of the file the data was parsed from.  Leave empty
#   ## to disable. Cautious when file name variation is high, this can increase the cardinality
#   ## significantly. Read more about cardinality here:
#   ## https://docs.influxdata.com/influxdb/cloud/reference/glossary/#series-cardinality
#   # file_tag = ""
#   #
#
#   ## Character encoding to use when interpreting the file contents.  Invalid
#   ## characters are replaced using the unicode replacement character.  When set
#   ## to the empty string the data is not decoded to text.
#   ##   ex: character_encoding = "utf-8"
#   ##       character_encoding = "utf-16le"
#   ##       character_encoding = "utf-16be"
#   ##       character_encoding = ""
#   # character_encoding = ""
#
#   ## The dataformat to be read from files
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   data_format = "influx"


# # Count files in a directory
# [[inputs.filecount]]
#   ## Directories to gather stats about.
#   ## This accept standard unit glob matching rules, but with the addition of
#   ## ** as a "super asterisk". ie:
#   ##   /var/log/**    -> recursively find all directories in /var/log and count files in each directories
#   ##   /var/log/*/*   -> find all directories with a parent dir in /var/log and count files in each directories
#   ##   /var/log       -> count all files in /var/log and all of its subdirectories
#   directories = ["/var/cache/apt/archives"]
#
#   ## Only count files that match the name pattern. Defaults to "*".
#   name = "*.deb"
#
#   ## Count files in subdirectories. Defaults to true.
#   recursive = false
#
#   ## Only count regular files. Defaults to true.
#   regular_only = true
#
#   ## Follow all symlinks while walking the directory tree. Defaults to false.
#   follow_symlinks = false
#
#   ## Only count files that are at least this size. If size is
#   ## a negative number, only count files that are smaller than the
#   ## absolute value of size. Acceptable units are B, KiB, MiB, KB, ...
#   ## Without quotes and units, interpreted as size in bytes.
#   size = "0B"
#
#   ## Only count files that have not been touched for at least this
#   ## duration. If mtime is negative, only count files that have been
#   ## touched in this duration. Defaults to "0s".
#   mtime = "0s"


# # Read stats about given file(s)
# [[inputs.filestat]]
#   ## Files to gather stats about.
#   ## These accept standard unix glob matching rules, but with the addition of
#   ## ** as a "super asterisk". ie:
#   ##   "/var/log/**.log"  -> recursively find all .log files in /var/log
#   ##   "/var/log/*/*.log" -> find all .log files with a parent dir in /var/log
#   ##   "/var/log/apache.log" -> just tail the apache log file
#   ##
#   ## See https://github.com/gobwas/glob for more examples
#   ##
#   files = ["/var/log/**.log"]
#
#   ## If true, read the entire file and calculate an md5 checksum.
#   md5 = false


# # Read real time temps from fireboard.io servers
# [[inputs.fireboard]]
#   ## Specify auth token for your account
#   auth_token = "invalidAuthToken"
#   ## You can override the fireboard server URL if necessary
#   # url = https://fireboard.io/api/v1/devices.json
#   ## You can set a different http_timeout if you need to
#   ## You should set a string using an number and time indicator
#   ## for example "12s" for 12 seconds.
#   # http_timeout = "4s"


# # Read metrics exposed by fluentd in_monitor plugin
# [[inputs.fluentd]]
#   ## This plugin reads information exposed by fluentd (using /api/plugins.json endpoint).
#   ##
#   ## Endpoint:
#   ## - only one URI is allowed
#   ## - https is not supported
#   endpoint = "http://localhost:24220/api/plugins.json"
#
#   ## Define which plugins have to be excluded (based on "type" field - e.g. monitor_agent)
#   exclude = [
# 	  "monitor_agent",
# 	  "dummy",
#   ]


# # Gather repository information from GitHub hosted repositories.
# [[inputs.github]]
#   ## List of repositories to monitor.
#   repositories = [
# 	  "influxdata/telegraf",
# 	  "influxdata/influxdb"
#   ]
#
#   ## Github API access token.  Unauthenticated requests are limited to 60 per hour.
#   # access_token = ""
#
#   ## Github API enterprise url. Github Enterprise accounts must specify their base url.
#   # enterprise_base_url = ""
#
#   ## Timeout for HTTP requests.
#   # http_timeout = "5s"
#
#   ## List of additional fields to query.
# 	## NOTE: Getting those fields might involve issuing additional API-calls, so please
# 	##       make sure you do not exceed the rate-limit of GitHub.
# 	##
# 	## Available fields are:
# 	## 	- pull-requests			-- number of open and closed pull requests (2 API-calls per repository)
#   # additional_fields = []


# # Read flattened metrics from one or more GrayLog HTTP endpoints
# [[inputs.graylog]]
#   ## API endpoint, currently supported API:
#   ##
#   ##   - multiple  (e.g. http://<host>:9000/api/system/metrics/multiple)
#   ##   - namespace (e.g. http://<host>:9000/api/system/metrics/namespace/{namespace})
#   ##
#   ## For namespace endpoint, the metrics array will be ignored for that call.
#   ## Endpoint can contain namespace and multiple type calls.
#   ##
#   ## Please check http://[graylog-server-ip]:9000/api/api-browser for full list
#   ## of endpoints
#   servers = [
#     "http://[graylog-server-ip]:9000/api/system/metrics/multiple",
#   ]
#
#   ## Set timeout (default 5 seconds)
#   # timeout = "5s"
#
#   ## Metrics list
#   ## List of metrics can be found on Graylog webservice documentation.
#   ## Or by hitting the web service api at:
#   ##   http://[graylog-host]:9000/api/system/metrics
#   metrics = [
#     "jvm.cl.loaded",
#     "jvm.memory.pools.Metaspace.committed"
#   ]
#
#   ## Username and password
#   username = ""
#   password = ""
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read metrics of haproxy, via socket or csv stats page
# [[inputs.haproxy]]
#   ## An array of address to gather stats about. Specify an ip on hostname
#   ## with optional port. ie localhost, 10.10.3.33:1936, etc.
#   ## Make sure you specify the complete path to the stats endpoint
#   ## including the protocol, ie http://10.10.3.33:1936/haproxy?stats
#
#   ## If no servers are specified, then default to 127.0.0.1:1936/haproxy?stats
#   servers = ["http://myhaproxy.com:1936/haproxy?stats"]
#
#   ## Credentials for basic HTTP authentication
#   # username = "admin"
#   # password = "admin"
#
#   ## You can also use local socket with standard wildcard globbing.
#   ## Server address not starting with 'http' will be treated as a possible
#   ## socket, so both examples below are valid.
#   # servers = ["socket:/run/haproxy/admin.sock", "/run/haproxy/*.sock"]
#
#   ## By default, some of the fields are renamed from what haproxy calls them.
#   ## Setting this option to true results in the plugin keeping the original
#   ## field names.
#   # keep_field_names = false
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Monitor disks' temperatures using hddtemp
# [[inputs.hddtemp]]
#   ## By default, telegraf gathers temps data from all disks detected by the
#   ## hddtemp.
#   ##
#   ## Only collect temps from the selected disks.
#   ##
#   ## A * as the device name will return the temperature values of all disks.
#   ##
#   # address = "127.0.0.1:7634"
#   # devices = ["sda", "*"]


# # Read formatted metrics from one or more HTTP endpoints
# [[inputs.http]]
#   ## One or more URLs from which to read formatted metrics
#   urls = [
#     "http://localhost/metrics"
#   ]
#
#   ## HTTP method
#   # method = "GET"
#
#   ## Optional HTTP headers
#   # headers = {"X-Special-Header" = "Special-Value"}
#
#   ## Optional file with Bearer token
#   ## file content is added as an Authorization header
#   # bearer_token = "/path/to/file"
#
#   ## Optional HTTP Basic Auth Credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## HTTP entity-body to send with POST/PUT requests.
#   # body = ""
#
#   ## HTTP Content-Encoding for write request body, can be set to "gzip" to
#   ## compress body or "identity" to apply no encoding.
#   # content_encoding = "identity"
#
#   ## HTTP Proxy support
#   # http_proxy_url = ""
#
#   ## OAuth2 Client Credentials Grant
#   # client_id = "clientid"
#   # client_secret = "secret"
#   # token_url = "https://indentityprovider/oauth2/v1/token"
#   # scopes = ["urn:opc:idm:__myscopes__"]
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Optional Cookie authentication
#   # cookie_auth_url = "https://localhost/authMe"
#   # cookie_auth_method = "POST"
#   # cookie_auth_username = "username"
#   # cookie_auth_password = "pa$$word"
#   # cookie_auth_headers = '{"Content-Type": "application/json", "X-MY-HEADER":"hello"}'
#   # cookie_auth_body = '{"username": "user", "password": "pa$$word", "authenticate": "me"}'
#   ## cookie_auth_renewal not set or set to "0" will auth once and never renew the cookie
#   # cookie_auth_renewal = "5m"
#
#   ## Amount of time allowed to complete the HTTP request
#   # timeout = "5s"
#
#   ## List of success status codes
#   # success_status_codes = [200]
#
#   ## Data format to consume.
#   ## Each data format has its own unique set of configuration options, read
#   ## more about them here:
#   ## https://github.com/influxdata/telegraf/blob/master/docs/DATA_FORMATS_INPUT.md
#   # data_format = "influx"


# # HTTP/HTTPS request given an address a method and a timeout
# [[inputs.http_response]]
#   ## List of urls to query.
#   # urls = ["http://localhost"]
#
#   ## Set http_proxy (telegraf uses the system wide proxy settings if it's is not set)
#   # http_proxy = "http://localhost:8888"
#
#   ## Set response_timeout (default 5 seconds)
#   # response_timeout = "5s"
#
#   ## HTTP Request Method
#   # method = "GET"
#
#   ## Whether to follow redirects from the server (defaults to false)
#   # follow_redirects = false
#
#   ## Optional file with Bearer token
#   ## file content is added as an Authorization header
#   # bearer_token = "/path/to/file"
#
#   ## Optional HTTP Basic Auth Credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## Optional HTTP Request Body
#   # body = '''
#   # {'fake':'data'}
#   # '''
#
#   ## Optional name of the field that will contain the body of the response.
#   ## By default it is set to an empty String indicating that the body's content won't be added
#   # response_body_field = ''
#
#   ## Maximum allowed HTTP response body size in bytes.
#   ## 0 means to use the default of 32MiB.
#   ## If the response body size exceeds this limit a "body_read_error" will be raised
#   # response_body_max_size = "32MiB"
#
#   ## Optional substring or regex match in body of the response (case sensitive)
#   # response_string_match = "\"service_status\": \"up\""
#   # response_string_match = "ok"
#   # response_string_match = "\".*_status\".?:.?\"up\""
#
#   ## Expected response status code.
#   ## The status code of the response is compared to this value. If they match, the field
#   ## "response_status_code_match" will be 1, otherwise it will be 0. If the
#   ## expected status code is 0, the check is disabled and the field won't be added.
#   # response_status_code = 0
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## HTTP Request Headers (all values must be strings)
#   # [inputs.http_response.headers]
#   #   Host = "github.com"
#
#   ## Optional setting to map response http headers into tags
#   ## If the http header is not present on the request, no corresponding tag will be added
#   ## If multiple instances of the http header are present, only the first value will be used
#   # http_header_tags = {"HTTP_HEADER" = "TAG_NAME"}
#
#   ## Interface to use when dialing an address
#   # interface = "eth0"


# # Read flattened metrics from one or more JSON HTTP endpoints
# [[inputs.httpjson]]
#   ## DEPRECATED: The 'httpjson' plugin is deprecated in version 1.6.0, use 'inputs.http' instead.
#   ## NOTE This plugin only reads numerical measurements, strings and booleans
#   ## will be ignored.
#
#   ## URL of each server in the service's cluster
#   servers = [
#     "http://localhost:9999/stats/",
#     "http://localhost:9998/stats/",
#   ]
#   ## Set response_timeout (default 5 seconds)
#   response_timeout = "5s"
#
#   ## HTTP method to use: GET or POST (case-sensitive)
#   method = "GET"
#
#   ## List of tag names to extract from top-level of JSON server response
#   # tag_keys = [
#   #   "my_tag_1",
#   #   "my_tag_2"
#   # ]
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## HTTP parameters (all values must be strings).  For "GET" requests, data
#   ## will be included in the query.  For "POST" requests, data will be included
#   ## in the request body as "x-www-form-urlencoded".
#   # [inputs.httpjson.parameters]
#   #   event_type = "cpu_spike"
#   #   threshold = "0.75"
#
#   ## HTTP Headers (all values must be strings)
#   # [inputs.httpjson.headers]
#   #   X-Auth-Token = "my-xauth-token"
#   #   apiVersion = "v1"


# # Gathers huge pages measurements.
# [[inputs.hugepages]]
#   ## Supported huge page types:
#   ##   - "root" - based on root huge page control directory: /sys/kernel/mm/hugepages
#   ##   - "per_node" - based on per NUMA node directories: /sys/devices/system/node/node[0-9]*/hugepages
#   ##   - "meminfo" - based on /proc/meminfo file
#   # types = ["root", "per_node"]


# # Gather Icinga2 status
# [[inputs.icinga2]]
#   ## Required Icinga2 server address
#   # server = "https://localhost:5665"
#
#   ## Required Icinga2 object type ("services" or "hosts")
#   # object_type = "services"
#
#   ## Credentials for basic HTTP authentication
#   # username = "admin"
#   # password = "admin"
#
#   ## Maximum time to receive response.
#   # response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = true


# # Gets counters from all InfiniBand cards and ports installed
# [[inputs.infiniband]]
#   # no configuration


# # Read InfluxDB-formatted JSON metrics from one or more HTTP endpoints
# [[inputs.influxdb]]
#   ## Works with InfluxDB debug endpoints out of the box,
#   ## but other services can use this format too.
#   ## See the influxdb plugin's README for more details.
#
#   ## Multiple URLs from which to read InfluxDB-formatted JSON
#   ## Default is "http://localhost:8086/debug/vars".
#   urls = [
#     "http://localhost:8086/debug/vars"
#   ]
#
#   ## Username and password to send using HTTP Basic Authentication.
#   # username = ""
#   # password = ""
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## http request & header timeout
#   timeout = "5s"


# # Intel PowerStat plugin enables monitoring of platform metrics (power, TDP) and Core metrics like temperature, power and utilization.
# [[inputs.intel_powerstat]]
#   ## All global metrics are always collected by Intel PowerStat plugin.
#   ## User can choose which per-CPU metrics are monitored by the plugin in cpu_metrics array.
#   ## Empty array means no per-CPU specific metrics will be collected by the plugin - in this case only platform level
#   ## telemetry will be exposed by Intel PowerStat plugin.
#   ## Supported options:
#   ## "cpu_frequency", "cpu_busy_frequency", "cpu_temperature", "cpu_c1_state_residency", "cpu_c6_state_residency", "cpu_busy_cycles"
#   # cpu_metrics = []


# # Collect statistics about itself
# [[inputs.internal]]
#   ## If true, collect telegraf memory stats.
#   # collect_memstats = true


# # Monitors internet speed using speedtest.net service
# [[inputs.internet_speed]]
#   ## Sets if runs file download test
#   # enable_file_download = false
#
#   ## Caches the closest server location
#   # cache = false


# # This plugin gathers interrupts data from /proc/interrupts and /proc/softirqs.
# [[inputs.interrupts]]
#   ## When set to true, cpu metrics are tagged with the cpu.  Otherwise cpu is
#   ## stored as a field.
#   ##
#   ## The default is false for backwards compatibility, and will be changed to
#   ## true in a future version.  It is recommended to set to true on new
#   ## deployments.
#   # cpu_as_tag = false
#
#   ## To filter which IRQs to collect, make use of tagpass / tagdrop, i.e.
#   # [inputs.interrupts.tagdrop]
#   #   irq = [ "NET_RX", "TASKLET" ]


# # Read metrics from the bare metal servers via IPMI
# [[inputs.ipmi_sensor]]
#   ## optionally specify the path to the ipmitool executable
#   # path = "/usr/bin/ipmitool"
#   ##
#   ## Setting 'use_sudo' to true will make use of sudo to run ipmitool.
#   ## Sudo must be configured to allow the telegraf user to run ipmitool
#   ## without a password.
#   # use_sudo = false
#   ##
#   ## optionally force session privilege level. Can be CALLBACK, USER, OPERATOR, ADMINISTRATOR
#   # privilege = "ADMINISTRATOR"
#   ##
#   ## optionally specify one or more servers via a url matching
#   ##  [username[:password]@][protocol[(address)]]
#   ##  e.g.
#   ##    root:passwd@lan(127.0.0.1)
#   ##
#   ## if no servers are specified, local machine sensor stats will be queried
#   ##
#   # servers = ["USERID:PASSW0RD@lan(192.168.1.1)"]
#
#   ## Recommended: use metric 'interval' that is a multiple of 'timeout' to avoid
#   ## gaps or overlap in pulled data
#   interval = "30s"
#
#   ## Timeout for the ipmitool command to complete
#   timeout = "20s"
#
#   ## Schema Version: (Optional, defaults to version 1)
#   metric_version = 2
#
#   ## Optionally provide the hex key for the IMPI connection.
#   # hex_key = ""
#
#   ## If ipmitool should use a cache
#   ## for me ipmitool runs about 2 to 10 times faster with cache enabled on HP G10 servers (when using ubuntu20.04)
#   ## the cache file may not work well for you if some sensors come up late
#   # use_cache = false
#
#   ## Path to the ipmitools cache file (defaults to OS temp dir)
#   ## The provided path must exist and must be writable
#   # cache_path = ""


# # Gather packets and bytes counters from Linux ipsets
# [[inputs.ipset]]
#   ## By default, we only show sets which have already matched at least 1 packet.
#   ## set include_unmatched_sets = true to gather them all.
#   include_unmatched_sets = false
#   ## Adjust your sudo settings appropriately if using this option ("sudo ipset save")
#   use_sudo = false
#   ## The default timeout of 1s for ipset execution can be overridden here:
#   # timeout = "1s"


# # Gather packets and bytes throughput from iptables
# [[inputs.iptables]]
#   ## iptables require root access on most systems.
#   ## Setting 'use_sudo' to true will make use of sudo to run iptables.
#   ## Users must configure sudo to allow telegraf user to run iptables with no password.
#   ## iptables can be restricted to only list command "iptables -nvL".
#   use_sudo = false
#   ## Setting 'use_lock' to true runs iptables with the "-w" option.
#   ## Adjust your sudo settings appropriately if using this option ("iptables -w 5 -nvl")
#   use_lock = false
#   ## Define an alternate executable, such as "ip6tables". Default is "iptables".
#   # binary = "ip6tables"
#   ## defines the table to monitor:
#   table = "filter"
#   ## defines the chains to monitor.
#   ## NOTE: iptables rules without a comment will not be monitored.
#   ## Read the plugin documentation for more information.
#   chains = [ "INPUT" ]


# # Collect virtual and real server stats from Linux IPVS
# [[inputs.ipvs]]
#   # no configuration


# # Read jobs and cluster metrics from Jenkins instances
# [[inputs.jenkins]]
#   ## The Jenkins URL in the format "schema://host:port"
#   url = "http://my-jenkins-instance:8080"
#   # username = "admin"
#   # password = "admin"
#
#   ## Set response_timeout
#   response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use SSL but skip chain & host verification
#   # insecure_skip_verify = false
#
#   ## Optional Max Job Build Age filter
#   ## Default 1 hour, ignore builds older than max_build_age
#   # max_build_age = "1h"
#
#   ## Optional Sub Job Depth filter
#   ## Jenkins can have unlimited layer of sub jobs
#   ## This config will limit the layers of pulling, default value 0 means
#   ## unlimited pulling until no more sub jobs
#   # max_subjob_depth = 0
#
#   ## Optional Sub Job Per Layer
#   ## In workflow-multibranch-plugin, each branch will be created as a sub job.
#   ## This config will limit to call only the lasted branches in each layer,
#   ## empty will use default value 10
#   # max_subjob_per_layer = 10
#
#   ## Jobs to include or exclude from gathering
#   ## When using both lists, job_exclude has priority.
#   ## Wildcards are supported: [ "jobA/*", "jobB/subjob1/*"]
#   # job_include = [ "*" ]
#   # job_exclude = [ ]
#
#   ## Nodes to include or exclude from gathering
#   ## When using both lists, node_exclude has priority.
#   # node_include = [ "*" ]
#   # node_exclude = [ ]
#
#   ## Worker pool for jenkins plugin only
#   ## Empty this field will use default value 5
#   # max_connections = 5


# # Read JMX metrics through Jolokia
# [[inputs.jolokia]]
#   ## DEPRECATED: The 'jolokia' plugin is deprecated in version 1.5.0, use 'inputs.jolokia2' instead.
#   # DEPRECATED: the jolokia plugin has been deprecated in favor of the
#   # jolokia2 plugin
#   # see https://github.com/influxdata/telegraf/tree/master/plugins/inputs/jolokia2
#
#   ## This is the context root used to compose the jolokia url
#   ## NOTE that Jolokia requires a trailing slash at the end of the context root
#   ## NOTE that your jolokia security policy must allow for POST requests.
#   context = "/jolokia/"
#
#   ## This specifies the mode used
#   # mode = "proxy"
#   #
#   ## When in proxy mode this section is used to specify further
#   ## proxy address configurations.
#   ## Remember to change host address to fit your environment.
#   # [inputs.jolokia.proxy]
#   #   host = "127.0.0.1"
#   #   port = "8080"
#
#   ## Optional http timeouts
#   ##
#   ## response_header_timeout, if non-zero, specifies the amount of time to wait
#   ## for a server's response headers after fully writing the request.
#   # response_header_timeout = "3s"
#   ##
#   ## client_timeout specifies a time limit for requests made by this client.
#   ## Includes connection time, any redirects, and reading the response body.
#   # client_timeout = "4s"
#
#   ## Attribute delimiter
#   ##
#   ## When multiple attributes are returned for a single
#   ## [inputs.jolokia.metrics], the field name is a concatenation of the metric
#   ## name, and the attribute name, separated by the given delimiter.
#   # delimiter = "_"
#
#   ## List of servers exposing jolokia read service
#   [[inputs.jolokia.servers]]
#     name = "as-server-01"
#     host = "127.0.0.1"
#     port = "8080"
#     # username = "myuser"
#     # password = "mypassword"
#
#   ## List of metrics collected on above servers
#   ## Each metric consists in a name, a jmx path and either
#   ## a pass or drop slice attribute.
#   ## This collect all heap memory usage metrics.
#   [[inputs.jolokia.metrics]]
#     name = "heap_memory_usage"
#     mbean  = "java.lang:type=Memory"
#     attribute = "HeapMemoryUsage"
#
#   ## This collect thread counts metrics.
#   [[inputs.jolokia.metrics]]
#     name = "thread_count"
#     mbean  = "java.lang:type=Threading"
#     attribute = "TotalStartedThreadCount,ThreadCount,DaemonThreadCount,PeakThreadCount"
#
#   ## This collect number of class loaded/unloaded counts metrics.
#   [[inputs.jolokia.metrics]]
#     name = "class_count"
#     mbean  = "java.lang:type=ClassLoading"
#     attribute = "LoadedClassCount,UnloadedClassCount,TotalLoadedClassCount"


# # Read JMX metrics from a Jolokia REST agent endpoint
# [[inputs.jolokia2_agent]]
#   # default_tag_prefix      = ""
#   # default_field_prefix    = ""
#   # default_field_separator = "."
#
#   # Add agents URLs to query
#   urls = ["http://localhost:8080/jolokia"]
#   # username = ""
#   # password = ""
#   # response_timeout = "5s"
#
#   ## Optional TLS config
#   # tls_ca   = "/var/private/ca.pem"
#   # tls_cert = "/var/private/client.pem"
#   # tls_key  = "/var/private/client-key.pem"
#   # insecure_skip_verify = false
#
#   ## Add metrics to read
#   [[inputs.jolokia2_agent.metric]]
#     name  = "java_runtime"
#     mbean = "java.lang:type=Runtime"
#     paths = ["Uptime"]


# # Read JMX metrics from a Jolokia REST proxy endpoint
# [[inputs.jolokia2_proxy]]
#   # default_tag_prefix      = ""
#   # default_field_prefix    = ""
#   # default_field_separator = "."
#
#   ## Proxy agent
#   url = "http://localhost:8080/jolokia"
#   # username = ""
#   # password = ""
#   # response_timeout = "5s"
#
#   ## Optional TLS config
#   # tls_ca   = "/var/private/ca.pem"
#   # tls_cert = "/var/private/client.pem"
#   # tls_key  = "/var/private/client-key.pem"
#   # insecure_skip_verify = false
#
#   ## Add proxy targets to query
#   # default_target_username = ""
#   # default_target_password = ""
#   [[inputs.jolokia2_proxy.target]]
#     url = "service:jmx:rmi:///jndi/rmi://targethost:9999/jmxrmi"
#     # username = ""
#     # password = ""
#
#   ## Add metrics to read
#   [[inputs.jolokia2_proxy.metric]]
#     name  = "java_runtime"
#     mbean = "java.lang:type=Runtime"
#     paths = ["Uptime"]


# # Read Kapacitor-formatted JSON metrics from one or more HTTP endpoints
# [[inputs.kapacitor]]
#   ## Multiple URLs from which to read Kapacitor-formatted JSON
#   ## Default is "http://localhost:9092/kapacitor/v1/debug/vars".
#   urls = [
#     "http://localhost:9092/kapacitor/v1/debug/vars"
#   ]
#
#   ## Time limit for http requests
#   timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Get kernel statistics from /proc/vmstat
# [[inputs.kernel_vmstat]]
#   # no configuration


# # Read status information from one or more Kibana servers
# [[inputs.kibana]]
#   ## Specify a list of one or more Kibana servers
#   servers = ["http://localhost:5601"]
#
#   ## Timeout for HTTP requests
#   timeout = "5s"
#
#   ## HTTP Basic Auth credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read metrics from the Kubernetes api
# [[inputs.kube_inventory]]
#   ## URL for the Kubernetes API
#   url = "https://127.0.0.1"
#
#   ## Namespace to use. Set to "" to use all namespaces.
#   # namespace = "default"
#
#   ## Use bearer token for authorization. ('bearer_token' takes priority)
#   ## If both of these are empty, we'll use the default serviceaccount:
#   ## at: /run/secrets/kubernetes.io/serviceaccount/token
#   # bearer_token = "/path/to/bearer/token"
#   ## OR
#   # bearer_token_string = "abc_123"
#
#   ## Set response_timeout (default 5 seconds)
#   # response_timeout = "5s"
#
#   ## Optional Resources to exclude from gathering
#   ## Leave them with blank with try to gather everything available.
#   ## Values can be - "daemonsets", deployments", "endpoints", "ingress", "nodes",
#   ## "persistentvolumes", "persistentvolumeclaims", "pods", "services", "statefulsets"
#   # resource_exclude = [ "deployments", "nodes", "statefulsets" ]
#
#   ## Optional Resources to include when gathering
#   ## Overrides resource_exclude if both set.
#   # resource_include = [ "deployments", "nodes", "statefulsets" ]
#
#   ## selectors to include and exclude as tags.  Globs accepted.
#   ## Note that an empty array for both will include all selectors as tags
#   ## selector_exclude overrides selector_include if both set.
#   # selector_include = []
#   # selector_exclude = ["*"]
#
#   ## Optional TLS Config
#   # tls_ca = "/path/to/cafile"
#   # tls_cert = "/path/to/certfile"
#   # tls_key = "/path/to/keyfile"
#   # tls_server_name = "kubernetes.example.com"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read metrics from the kubernetes kubelet api
# [[inputs.kubernetes]]
#   ## URL for the kubelet
#   url = "http://127.0.0.1:10255"
#
#   ## Use bearer token for authorization. ('bearer_token' takes priority)
#   ## If both of these are empty, we'll use the default serviceaccount:
#   ## at: /run/secrets/kubernetes.io/serviceaccount/token
#   # bearer_token = "/path/to/bearer/token"
#   ## OR
#   # bearer_token_string = "abc_123"
#
#   ## Pod labels to be added as tags.  An empty array for both include and
#   ## exclude will include all labels.
#   # label_include = []
#   # label_exclude = ["*"]
#
#   ## Set response_timeout (default 5 seconds)
#   # response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = /path/to/cafile
#   # tls_cert = /path/to/certfile
#   # tls_key = /path/to/keyfile
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read metrics from a LeoFS Server via SNMP
# [[inputs.leofs]]
#   ## An array of URLs of the form:
#   ##   host [ ":" port]
#   servers = ["127.0.0.1:4020"]


# # Provides Linux sysctl fs metrics
# [[inputs.linux_sysctl_fs]]
#   # no configuration


# # Read metrics exposed by Logstash
# [[inputs.logstash]]
#   ## The URL of the exposed Logstash API endpoint.
#   url = "http://127.0.0.1:9600"
#
#   ## Use Logstash 5 single pipeline API, set to true when monitoring
#   ## Logstash 5.
#   # single_pipeline = false
#
#   ## Enable optional collection components.  Can contain
#   ## "pipelines", "process", and "jvm".
#   # collect = ["pipelines", "process", "jvm"]
#
#   ## Timeout for HTTP requests.
#   # timeout = "5s"
#
#   ## Optional HTTP Basic Auth credentials.
#   # username = "username"
#   # password = "pa$$word"
#
#   ## Optional TLS Config.
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#
#   ## Use TLS but skip chain & host verification.
#   # insecure_skip_verify = false
#
#   ## Optional HTTP headers.
#   # [inputs.logstash.headers]
#   #   "X-Special-Header" = "Special-Value"


# # Read metrics from local Lustre service on OST, MDS
# [[inputs.lustre2]]
#   ## An array of /proc globs to search for Lustre stats
#   ## If not specified, the default will work on Lustre 2.5.x
#   ##
#   # ost_procfiles = [
#   #   "/proc/fs/lustre/obdfilter/*/stats",
#   #   "/proc/fs/lustre/osd-ldiskfs/*/stats",
#   #   "/proc/fs/lustre/obdfilter/*/job_stats",
#   # ]
#   # mds_procfiles = [
#   #   "/proc/fs/lustre/mdt/*/md_stats",
#   #   "/proc/fs/lustre/mdt/*/job_stats",
#   # ]


# # Read metrics about LVM physical volumes, volume groups, logical volumes.
# [[inputs.lvm]]
# ## Use sudo to run LVM commands
# use_sudo = false


# # Gathers metrics from the /3.0/reports MailChimp API
# [[inputs.mailchimp]]
#   ## MailChimp API key
#   ## get from https://admin.mailchimp.com/account/api/
#   api_key = "" # required
#   ## Reports for campaigns sent more than days_old ago will not be collected.
#   ## 0 means collect all.
#   days_old = 0
#   ## Campaign ID to get, if empty gets all campaigns, this option overrides days_old
#   # campaign_id = ""


# # Retrieves information on a specific host in a MarkLogic Cluster
# [[inputs.marklogic]]
#   ## Base URL of the MarkLogic HTTP Server.
#   url = "http://localhost:8002"
#
#   ## List of specific hostnames to retrieve information. At least (1) required.
#   # hosts = ["hostname1", "hostname2"]
#
#   ## Using HTTP Basic Authentication. Management API requires 'manage-user' role privileges
#   # username = "myuser"
#   # password = "mypassword"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read metrics from one or many mcrouter servers
# [[inputs.mcrouter]]
#   ## An array of address to gather stats about. Specify an ip or hostname
#   ## with port. ie tcp://localhost:11211, tcp://10.0.0.1:11211, etc.
# 	servers = ["tcp://localhost:11211", "unix:///var/run/mcrouter.sock"]
#
# 	## Timeout for metric collections from all servers.  Minimum timeout is "1s".
#   # timeout = "5s"


# # Get md array statistics from /proc/mdstat
# [[inputs.mdstat]]
# 	## Sets file path
# 	## If not specified, then default is /proc/mdstat
# 	# file_name = "/proc/mdstat"


# # Read metrics from one or many memcached servers
# [[inputs.memcached]]
#   ## An array of address to gather stats about. Specify an ip on hostname
#   ## with optional port. ie localhost, 10.0.0.1:11211, etc.
#   servers = ["localhost:11211"]
#   # unix_sockets = ["/var/run/memcached.sock"]
#
#   ## Optional TLS Config
#   # enable_tls = true
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## If false, skip chain & host verification
#   # insecure_skip_verify = true


# # Telegraf plugin for gathering metrics from N Mesos masters
# [[inputs.mesos]]
#   ## Timeout, in ms.
#   timeout = 100
#
#   ## A list of Mesos masters.
#   masters = ["http://localhost:5050"]
#
#   ## Master metrics groups to be collected, by default, all enabled.
#   master_collections = [
#     "resources",
#     "master",
#     "system",
#     "agents",
#     "frameworks",
#     "framework_offers",
#     "tasks",
#     "messages",
#     "evqueue",
#     "registrar",
#     "allocator",
#   ]
#
#   ## A list of Mesos slaves, default is []
#   # slaves = []
#
#   ## Slave metrics groups to be collected, by default, all enabled.
#   # slave_collections = [
#   #   "resources",
#   #   "agent",
#   #   "system",
#   #   "executors",
#   #   "tasks",
#   #   "messages",
#   # ]
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Collects scores from a Minecraft server's scoreboard using the RCON protocol
# [[inputs.minecraft]]
#   ## Address of the Minecraft server.
#   # server = "localhost"
#
#   ## Server RCON Port.
#   # port = "25575"
#
#   ## Server RCON Password.
#   password = ""
#
#   ## Uncomment to remove deprecated metric components.
#   # tagdrop = ["server"]


# # Generate metrics for test and demonstration purposes
# [[inputs.mock]]
#   ## Set the metric name to use for reporting
#   metric_name = "mock"
#
#   ## Optional string key-value pairs of tags to add to all metrics
#   # [inputs.mock.tags]
#   # "key" = "value"
#
#   ## One or more mock data fields *must* be defined.
#   ##
#   ## [[inputs.mock.random]]
#   ##   name = "rand"
#   ##   min = 1.0
#   ##   max = 6.0
#   ## [[inputs.mock.sine_wave]]
#   ##   name = "wave"
#   ##   amplitude = 1.0
#   ##   period = 0.5
#   ## [[inputs.mock.step]]
#   ##   name = "plus_one"
#   ##   start = 0.0
#   ##   step = 1.0
#   ## [[inputs.mock.stock]]
#   ##   name = "abc"
#   ##   price = 50.00
#   ##   volatility = 0.2


# # Retrieve data from MODBUS slave devices
# [[inputs.modbus]]
#   ## Connection Configuration
#   ##
#   ## The plugin supports connections to PLCs via MODBUS/TCP, RTU over TCP, ASCII over TCP or
#   ## via serial line communication in binary (RTU) or readable (ASCII) encoding
#   ##
#   ## Device name
#   name = "Device"
#
#   ## Slave ID - addresses a MODBUS device on the bus
#   ## Range: 0 - 255 [0 = broadcast; 248 - 255 = reserved]
#   slave_id = 1
#
#   ## Timeout for each request
#   timeout = "1s"
#
#   ## Maximum number of retries and the time to wait between retries
#   ## when a slave-device is busy.
#   # busy_retries = 0
#   # busy_retries_wait = "100ms"
#
#   # TCP - connect via Modbus/TCP
#   controller = "tcp://localhost:502"
#
#   ## Serial (RS485; RS232)
#   # controller = "file:///dev/ttyUSB0"
#   # baud_rate = 9600
#   # data_bits = 8
#   # parity = "N"
#   # stop_bits = 1
#
#   ## Trace the connection to the modbus device as debug messages
#   ## Note: You have to enable telegraf's debug mode to see those messages!
#   # debug_connection = false
#
#   ## For Modbus over TCP you can choose between "TCP", "RTUoverTCP" and "ASCIIoverTCP"
#   ## default behaviour is "TCP" if the controller is TCP
#   ## For Serial you can choose between "RTU" and "ASCII"
#   # transmission_mode = "RTU"
#
# 	## Define the configuration schema
#   ##  |---register -- define fields per register type in the original style (only supports one slave ID)
#   ##  |---request  -- define fields on a requests base
#   configuration_type = "register"
#
#   ## Per register definition
#   ##
#
#   ## Digital Variables, Discrete Inputs and Coils
#   ## measurement - the (optional) measurement name, defaults to "modbus"
#   ## name        - the variable name
#   ## address     - variable address
#
#   discrete_inputs = [
#     { name = "start",          address = [0]},
#     { name = "stop",           address = [1]},
#     { name = "reset",          address = [2]},
#     { name = "emergency_stop", address = [3]},
#   ]
#   coils = [
#     { name = "motor1_run",     address = [0]},
#     { name = "motor1_jog",     address = [1]},
#     { name = "motor1_stop",    address = [2]},
#   ]
#
#   ## Analog Variables, Input Registers and Holding Registers
#   ## measurement - the (optional) measurement name, defaults to "modbus"
#   ## name        - the variable name
#   ## byte_order  - the ordering of bytes
#   ##  |---AB, ABCD   - Big Endian
#   ##  |---BA, DCBA   - Little Endian
#   ##  |---BADC       - Mid-Big Endian
#   ##  |---CDAB       - Mid-Little Endian
#   ## data_type  - INT16, UINT16, INT32, UINT32, INT64, UINT64,
#   ##              FLOAT32-IEEE, FLOAT64-IEEE (the IEEE 754 binary representation)
#   ##              FLOAT32, FIXED, UFIXED (fixed-point representation on input)
#   ## scale      - the final numeric variable representation
#   ## address    - variable address
#
#   holding_registers = [
#     { name = "power_factor", byte_order = "AB",   data_type = "FIXED", scale=0.01,  address = [8]},
#     { name = "voltage",      byte_order = "AB",   data_type = "FIXED", scale=0.1,   address = [0]},
#     { name = "energy",       byte_order = "ABCD", data_type = "FIXED", scale=0.001, address = [5,6]},
#     { name = "current",      byte_order = "ABCD", data_type = "FIXED", scale=0.001, address = [1,2]},
#     { name = "frequency",    byte_order = "AB",   data_type = "UFIXED", scale=0.1,  address = [7]},
#     { name = "power",        byte_order = "ABCD", data_type = "UFIXED", scale=0.1,  address = [3,4]},
#   ]
#   input_registers = [
#     { name = "tank_level",   byte_order = "AB",   data_type = "INT16",   scale=1.0,     address = [0]},
#     { name = "tank_ph",      byte_order = "AB",   data_type = "INT16",   scale=1.0,     address = [1]},
#     { name = "pump1_speed",  byte_order = "ABCD", data_type = "INT32",   scale=1.0,     address = [3,4]},
#   ]
#
#
#   ## Per request definition
#   ##
#
#   ## Define a request sent to the device
#   ## Multiple of those requests can be defined. Data will be collated into metrics at the end of data collection.
#   # [[inputs.modbus.request]]
#     ## ID of the modbus slave device to query.
#     ## If you need to query multiple slave-devices, create several "request" definitions.
#     # slave_id = 0
#
#     ## Byte order of the data.
#     ##  |---ABCD or MSW-BE -- Big Endian (Motorola)
#     ##  |---DCBA or LSW-LE -- Little Endian (Intel)
#     ##  |---BADC or MSW-LE -- Big Endian with byte swap
#     ##  |---CDAB or LSW-BE -- Little Endian with byte swap
#     # byte_order = "ABCD"
#
#     ## Type of the register for the request
#     ## Can be "coil", "discrete", "holding" or "input"
#     # register = "holding"
#
#     ## Name of the measurement.
#     ## Can be overriden by the individual field definitions. Defaults to "modbus"
#     # measurement = "modbus"
#
#     ## Field definitions
#     ## Analog Variables, Input Registers and Holding Registers
#     ## address        - address of the register to query. For coil and discrete inputs this is the bit address.
#     ## name *1        - field name
#     ## type *1,2      - type of the modbus field, can be INT16, UINT16, INT32, UINT32, INT64, UINT64 and
#     ##                  FLOAT32, FLOAT64 (IEEE 754 binary representation)
#     ## scale *1,2     - (optional) factor to scale the variable with
#     ## output *1,2    - (optional) type of resulting field, can be INT64, UINT64 or FLOAT64. Defaults to FLOAT64 if
#     ##                  "scale" is provided and to the input "type" class otherwise (i.e. INT* -> INT64, etc).
#     ## measurement *1 - (optional) measurement name, defaults to the setting of the request
#     ## omit           - (optional) omit this field. Useful to leave out single values when querying many registers
#     ##                  with a single request. Defaults to "false".
#     ##
#     ## *1: Those fields are ignored if field is omitted ("omit"=true)
#     ##
#     ## *2: Thise fields are ignored for both "coil" and "discrete"-input type of registers. For those register types
#     ##     the fields are output as zero or one in UINT64 format by default.
#
#     ## Coil / discrete input example
#     # fields = [
#     #   { address=0, name="motor1_run"},
#     #   { address=1, name="jog", measurement="motor"},
#     #   { address=2, name="motor1_stop", omit=true},
#     #   { address=3, name="motor1_overheating"},
#     # ]
#
#     ## Per-request tags
#     ## These tags take precedence over predefined tags.
#     # [[inputs.modbus.request.tags]]
#     #	  name = "value"
#
#     ## Holding / input example
#     ## All of those examples will result in FLOAT64 field outputs
#     # fields = [
#     #   { address=0, name="voltage",      type="INT16",   scale=0.1   },
#     #   { address=1, name="current",      type="INT32",   scale=0.001 },
#     #   { address=3, name="power",        type="UINT32",  omit=true   },
#     #   { address=5, name="energy",       type="FLOAT32", scale=0.001, measurement="W" },
#     #   { address=7, name="frequency",    type="UINT32",  scale=0.1   },
#     #   { address=8, name="power_factor", type="INT64",   scale=0.01  },
#     # ]
#
#     ## Holding / input example with type conversions
#     # fields = [
#     #   { address=0, name="rpm",         type="INT16"                   },  # will result in INT64 field
#     #   { address=1, name="temperature", type="INT16", scale=0.1        },  # will result in FLOAT64 field
#     #   { address=2, name="force",       type="INT32", output="FLOAT64" },  # will result in FLOAT64 field
#     #   { address=4, name="hours",       type="UINT32"                  },  # will result in UIN64 field
#     # ]
#
#     ## Per-request tags
# 		## These tags take precedence over predefined tags.
#     # [[inputs.modbus.request.tags]]
#     #	  name = "value"
#
#
#
#   ## Enable workarounds required by some devices to work correctly
#   # [inputs.modbus.workarounds]
#     ## Pause between read requests sent to the device. This might be necessary for (slow) serial devices.
#     # pause_between_requests = "0ms"
#     ## Close the connection after every gather cycle. Usually the plugin closes the connection after a certain
#     ## idle-timeout, however, if you query a device with limited simultaneous connectivity (e.g. serial devices)
#     ## from multiple instances you might want to only stay connected during gather and disconnect afterwards.
#     # close_connection_after_gather = false


# # Read metrics from one or many MongoDB servers
# [[inputs.mongodb]]
#   ## An array of URLs of the form:
#   ##   "mongodb://" [user ":" pass "@"] host [ ":" port]
#   ## For example:
#   ##   mongodb://user:auth_key@10.10.3.30:27017,
#   ##   mongodb://10.10.3.33:18832,
#   servers = ["mongodb://127.0.0.1:27017?connect=direct"]
#
#   ## When true, collect cluster status
#   ## Note that the query that counts jumbo chunks triggers a COLLSCAN, which
#   ## may have an impact on performance.
#   # gather_cluster_status = true
#
#   ## When true, collect per database stats
#   # gather_perdb_stats = false
#
#   ## When true, collect per collection stats
#   # gather_col_stats = false
#
#   ## When true, collect usage statistics for each collection
#   ## (insert, update, queries, remove, getmore, commands etc...).
#   # gather_top_stat = false
#
#   ## List of db where collections stats are collected
#   ## If empty, all db are concerned
#   # col_stats_dbs = ["local"]
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read metrics and status information about processes managed by Monit
# [[inputs.monit]]
#   ## Monit HTTPD address
#   address = "http://127.0.0.1:2812"
#
#   ## Username and Password for Monit
#   # username = ""
#   # password = ""
#
#   ## Amount of time allowed to complete the HTTP request
#   # timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Aggregates the contents of multiple files into a single point
# [[inputs.multifile]]
#   ## Base directory where telegraf will look for files.
#   ## Omit this option to use absolute paths.
#   base_dir = "/sys/bus/i2c/devices/1-0076/iio:device0"
#
#   ## If true, Telegraf discard all data when a single file can't be read.
#   ## Else, Telegraf omits the field generated from this file.
#   # fail_early = true
#
#   ## Files to parse each interval.
#   [[inputs.multifile.file]]
#     file = "in_pressure_input"
#     dest = "pressure"
#     conversion = "float"
#   [[inputs.multifile.file]]
#     file = "in_temp_input"
#     dest = "temperature"
#     conversion = "float(3)"
#   [[inputs.multifile.file]]
#     file = "in_humidityrelative_input"
#     dest = "humidityrelative"
#     conversion = "float(3)"


# # Read metrics from one or many mysql servers
# [[inputs.mysql]]
#   ## specify servers via a url matching:
#   ##  [username[:password]@][protocol[(address)]]/[?tls=[true|false|skip-verify|custom]]
#   ##  see https://github.com/go-sql-driver/mysql#dsn-data-source-name
#   ##  e.g.
#   ##    servers = ["user:passwd@tcp(127.0.0.1:3306)/?tls=false"]
#   ##    servers = ["user@tcp(127.0.0.1:3306)/?tls=false"]
#   #
#   ## If no servers are specified, then localhost is used as the host.
#   servers = ["tcp(127.0.0.1:3306)/"]
#
#   ## Selects the metric output format.
#   ##
#   ## This option exists to maintain backwards compatibility, if you have
#   ## existing metrics do not set or change this value until you are ready to
#   ## migrate to the new format.
#   ##
#   ## If you do not have existing metrics from this plugin set to the latest
#   ## version.
#   ##
#   ## Telegraf >=1.6: metric_version = 2
#   ##           <1.6: metric_version = 1 (or unset)
#   metric_version = 2
#
#   ## if the list is empty, then metrics are gathered from all database tables
#   # table_schema_databases = []
#
#   ## gather metrics from INFORMATION_SCHEMA.TABLES for databases provided above list
#   # gather_table_schema = false
#
#   ## gather thread state counts from INFORMATION_SCHEMA.PROCESSLIST
#   # gather_process_list = false
#
#   ## gather user statistics from INFORMATION_SCHEMA.USER_STATISTICS
#   # gather_user_statistics = false
#
#   ## gather auto_increment columns and max values from information schema
#   # gather_info_schema_auto_inc = false
#
#   ## gather metrics from INFORMATION_SCHEMA.INNODB_METRICS
#   # gather_innodb_metrics = false
#
#   ## gather metrics from SHOW SLAVE STATUS command output
#   # gather_slave_status = false
#
#   ## gather metrics from all channels from SHOW SLAVE STATUS command output
#   # gather_all_slave_channels = false
#
#   ## use MariaDB dialect for all channels SHOW SLAVE STATUS
#   # mariadb_dialect = false
#
#   ## gather metrics from SHOW BINARY LOGS command output
#   # gather_binary_logs = false
#
#   ## gather metrics from PERFORMANCE_SCHEMA.GLOBAL_VARIABLES
#   # gather_global_variables = true
#
#   ## gather metrics from PERFORMANCE_SCHEMA.TABLE_IO_WAITS_SUMMARY_BY_TABLE
#   # gather_table_io_waits = false
#
#   ## gather metrics from PERFORMANCE_SCHEMA.TABLE_LOCK_WAITS
#   # gather_table_lock_waits = false
#
#   ## gather metrics from PERFORMANCE_SCHEMA.TABLE_IO_WAITS_SUMMARY_BY_INDEX_USAGE
#   # gather_index_io_waits = false
#
#   ## gather metrics from PERFORMANCE_SCHEMA.EVENT_WAITS
#   # gather_event_waits = false
#
#   ## gather metrics from PERFORMANCE_SCHEMA.FILE_SUMMARY_BY_EVENT_NAME
#   # gather_file_events_stats = false
#
#   ## gather metrics from PERFORMANCE_SCHEMA.EVENTS_STATEMENTS_SUMMARY_BY_DIGEST
#   # gather_perf_events_statements = false
#
#   ## the limits for metrics form perf_events_statements
#   # perf_events_statements_digest_text_limit = 120
#   # perf_events_statements_limit = 250
#   # perf_events_statements_time_limit = 86400
#
#   ## gather metrics from PERFORMANCE_SCHEMA.EVENTS_STATEMENTS_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME
#   # gather_perf_sum_per_acc_per_event         = false
#
#   ## list of events to be gathered for gather_perf_sum_per_acc_per_event
#   ## in case of empty list all events will be gathered
#   # perf_summary_events                       = []
#
#   ## Some queries we may want to run less often (such as SHOW GLOBAL VARIABLES)
#   ##   example: interval_slow = "30m"
#   # interval_slow = ""
#
#   ## Optional TLS Config (will be used if tls=custom parameter specified in server uri)
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Provides metrics about the state of a NATS server
# [[inputs.nats]]
#   ## The address of the monitoring endpoint of the NATS server
#   server = "http://localhost:8222"
#
#   ## Maximum time to receive response
#   # response_timeout = "5s"


# # Neptune Apex data collector
# [[inputs.neptune_apex]]
#   ## The Neptune Apex plugin reads the publicly available status.xml data from a local Apex.
#   ## Measurements will be logged under "apex".
#
#   ## The base URL of the local Apex(es). If you specify more than one server, they will
#   ## be differentiated by the "source" tag.
#   servers = [
#     "http://apex.local",
#   ]
#
#   ## The response_timeout specifies how long to wait for a reply from the Apex.
#   #response_timeout = "5s"


# # Read metrics about network interface usage
# [[inputs.net]]
#   ## By default, telegraf gathers stats from any up interface (excluding loopback)
#   ## Setting interfaces will tell it to gather these explicit interfaces,
#   ## regardless of status.
#   ##
#   # interfaces = ["eth0"]
#   ##
#   ## On linux systems telegraf also collects protocol stats.
#   ## Setting ignore_protocol_stats to true will skip reporting of protocol metrics.
#   ##
#   # ignore_protocol_stats = false
#   ##


# # Collect response time of a TCP or UDP connection
# [[inputs.net_response]]
#   ## Protocol, must be "tcp" or "udp"
#   ## NOTE: because the "udp" protocol does not respond to requests, it requires
#   ## a send/expect string pair (see below).
#   protocol = "tcp"
#   ## Server address (default localhost)
#   address = "localhost:80"
#
#   ## Set timeout
#   # timeout = "1s"
#
#   ## Set read timeout (only used if expecting a response)
#   # read_timeout = "1s"
#
#   ## The following options are required for UDP checks. For TCP, they are
#   ## optional. The plugin will send the given string to the server and then
#   ## expect to receive the given 'expect' string back.
#   ## string sent to the server
#   # send = "ssh"
#   ## expected string in answer
#   # expect = "ssh"
#
#   ## Uncomment to remove deprecated fields
#   # fielddrop = ["result_type", "string_found"]


# # Read TCP metrics such as established, time wait and sockets counts.
# [[inputs.netstat]]
#   # no configuration


# # Read per-mount NFS client metrics from /proc/self/mountstats
# [[inputs.nfsclient]]
#   ## Read more low-level metrics (optional, defaults to false)
#   # fullstat = false
#
#   ## List of mounts to explictly include or exclude (optional)
#   ## The pattern (Go regexp) is matched against the mount point (not the
#   ## device being mounted).  If include_mounts is set, all mounts are ignored
#   ## unless present in the list. If a mount is listed in both include_mounts
#   ## and exclude_mounts, it is excluded.  Go regexp patterns can be used.
#   # include_mounts = []
#   # exclude_mounts = []
#
#   ## List of operations to include or exclude from collecting.  This applies
#   ## only when fullstat=true.  Symantics are similar to {include,exclude}_mounts:
#   ## the default is to collect everything; when include_operations is set, only
#   ## those OPs are collected; when exclude_operations is set, all are collected
#   ## except those listed.  If include and exclude are set, the OP is excluded.
#   ## See /proc/self/mountstats for a list of valid operations; note that
#   ## NFSv3 and NFSv4 have different lists.  While it is not possible to
#   ## have different include/exclude lists for NFSv3/4, unused elements
#   ## in the list should be okay.  It is possible to have different lists
#   ## for different mountpoints:  use mulitple [[input.nfsclient]] stanzas,
#   ## with their own lists.  See "include_mounts" above, and be careful of
#   ## duplicate metrics.
#   # include_operations = []
#   # exclude_operations = []


# # Read Nginx's basic status information (ngx_http_stub_status_module)
# [[inputs.nginx]]
#   # An array of Nginx stub_status URI to gather stats.
#   urls = ["http://localhost/server_status"]
#
#   ## Optional TLS Config
#   tls_ca = "/etc/telegraf/ca.pem"
#   tls_cert = "/etc/telegraf/cert.cer"
#   tls_key = "/etc/telegraf/key.key"
#   ## Use TLS but skip chain & host verification
#   insecure_skip_verify = false
#
#   # HTTP response timeout (default: 5s)
#   response_timeout = "5s"


# # Read Nginx Plus' full status information (ngx_http_status_module)
# [[inputs.nginx_plus]]
#   ## An array of ngx_http_status_module or status URI to gather stats.
#   urls = ["http://localhost/status"]
#
#   # HTTP response timeout (default: 5s)
#   response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read Nginx Plus Api documentation
# [[inputs.nginx_plus_api]]
#   ## An array of API URI to gather stats.
#   urls = ["http://localhost/api"]
#
#   # Nginx API version, default: 3
#   # api_version = 3
#
#   # HTTP response timeout (default: 5s)
#   response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read Nginx virtual host traffic status module information (nginx-module-sts)
# [[inputs.nginx_sts]]
#   ## An array of ngx_http_status_module or status URI to gather stats.
#   urls = ["http://localhost/status"]
#
#   ## HTTP response timeout (default: 5s)
#   response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read nginx_upstream_check module status information (https://github.com/yaoweibin/nginx_upstream_check_module)
# [[inputs.nginx_upstream_check]]
#   ## An URL where Nginx Upstream check module is enabled
#   ## It should be set to return a JSON formatted response
#   url = "http://127.0.0.1/status?format=json"
#
#   ## HTTP method
#   # method = "GET"
#
#   ## Optional HTTP headers
#   # headers = {"X-Special-Header" = "Special-Value"}
#
#   ## Override HTTP "Host" header
#   # host_header = "check.example.com"
#
#   ## Timeout for HTTP requests
#   timeout = "5s"
#
#   ## Optional HTTP Basic Auth credentials
#   # username = "username"
#   # password = "pa$$word"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read Nginx virtual host traffic status module information (nginx-module-vts)
# [[inputs.nginx_vts]]
#   ## An array of ngx_http_status_module or status URI to gather stats.
#   urls = ["http://localhost/status"]
#
#   ## HTTP response timeout (default: 5s)
#   response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Read metrics from the Nomad API
# [[inputs.nomad]]
#   ## URL for the Nomad agent
#   # url = "http://127.0.0.1:4646"
#
#   ## Set response_timeout (default 5 seconds)
#   # response_timeout = "5s"
#
#   ## Optional TLS Config
#   # tls_ca = /path/to/cafile
#   # tls_cert = /path/to/certfile
#   # tls_key = /path/to/keyfile


# # A plugin to collect stats from the NSD authoritative DNS name server
# [[inputs.nsd]]
#   ## Address of server to connect to, optionally ':port'. Defaults to the
#   ## address in the nsd config file.
#   server = "127.0.0.1:8953"
#
#   ## If running as a restricted user you can prepend sudo for additional access:
#   # use_sudo = false
#
#   ## The default location of the nsd-control binary can be overridden with:
#   # binary = "/usr/sbin/nsd-control"
#
#   ## The default location of the nsd config file can be overridden with:
#   # config_file = "/etc/nsd/nsd.conf"
#
#   ## The default timeout of 1s can be overridden with:
#   # timeout = "1s"


# # Read NSQ topic and channel statistics.
# [[inputs.nsq]]
#   ## An array of NSQD HTTP API endpoints
#   endpoints  = ["http://localhost:4151"]
#
#   ## Optional TLS Config
#   # tls_ca = "/etc/telegraf/ca.pem"
#   # tls_cert = "/etc/telegraf/cert.pem"
#   # tls_key = "/etc/telegraf/key.pem"
#   ## Use TLS but skip chain & host verification
#   # insecure_skip_verify = false


# # Collect kernel snmp counters and network interface statistics
# [[inputs.nstat]]
#   ## file paths for proc files. If empty default paths will be used:
#   ##    /proc/net/netstat, /proc/net/snmp, /proc/net/snmp6
#   ## These can also be overridden with env variables, see README.
#   proc_net_netstat = "/proc/net/netstat"
#   proc_net_snmp = "/proc/net/snmp"
#   proc_net_snmp6 = "/proc/net/snmp6"
#   ## dump metrics with 0 values too
#   dump_zeros       = true


# # Get standard NTP query metrics, requires ntpq executable.
# [[inputs.ntpq]]
#   ## If false, set the -n ntpq flag. Can reduce metric gather time.
#   dns_lookup = true


# # Pulls statistics from nvidia GPUs attached to the host
# [[inputs.nvidia_smi]]
#   ## Optional: path to nvidia-smi binary, defaults "/usr/bin/nvidia-smi"
#   ## We will first try to locate the nvidia-smi binary with the explicitly specified value (or default value),
#   ## if it is not found, we will try to locate it on PATH(exec.LookPath), if it is still not found, an error will be returned
#   # bin_path = "/usr/bin/nvidia-smi"
#
#   ## Optional: timeout for GPU polling
#   # timeout = "5s"


# # Retrieve data from OPCUA devices
[[inputs.opcua]]
#   ## Metric name
  name = "test"
#   #
#   ## OPC UA Endpoint URL
  endpoint = "opc.tcp://192.168.248.40:4990/FactoryTalkLinxGateway1"
#   #
#   ## Maximum time allowed to establish a connect to the endpoint.
  connect_timeout = "10s"
#   #
#   ## Maximum time allowed for a request over the estabilished connection.
  request_timeout = "5s"
#   #
#   ## Security policy, one of "None", "Basic128Rsa15", "Basic256",
#   ## "Basic256Sha256", or "auto"
  security_policy = "None"
#   #
#   ## Security mode, one of "None", "Sign", "SignAndEncrypt", or "auto"
  security_mode = "None"
#   #
#   ## Path to cert.pem. Required when security mode or policy isn't "None".
#   ## If cert path is not supplied, self-signed cert and key will be generated.
  certificate = ""
#   #
#   ## Path to private key.pem. Required when security mode or policy isn't "None".
#   ## If key path is not supplied, self-signed cert and key will be generated.
  private_key = ""
#   #
#   ## Authentication Method, one of "Certificate", "UserName", or "Anonymous".  To
#   ## authenticate using a specific ID, select 'Certificate' or 'UserName'
  auth_method = "Anonymous"
#   #
#   ## Username. Required for auth_method = "UserName"
  username = ""
#   #
#   ## Password. Required for auth_method = "UserName"
  password = ""
#   #
#   ## Option to select the metric timestamp to use. Valid options are:
#   ##     "gather" -- uses the time of receiving the data in telegraf
#   ##     "server" -- uses the timestamp provided by the server
#   ##     "source" -- uses the timestamp provided by the source
  timestamp = "source"
#   #
#   ## Node ID configuration
#   ## name              - field name to use in the output
#   ## namespace         - OPC UA namespace of the node (integer value 0 thru 3)
#   ## identifier_type   - OPC UA ID type (s=string, i=numeric, g=guid, b=opaque)
#   ## identifier        - OPC UA ID (tag as shown in opcua browser)
#   ## Example:
#   ## {name="ProductUri", namespace="0", identifier_type="i", identifier="2262"}
  [[inputs.opcua.group]]
  name="PLC"
  namespace="2"
  identifier_type="s"
  tags=[["Part","PLC_Utility"]]
  nodes = [
   {name="CpuControl", namespace="2", identifier_type="s", identifier="[CookieLine]CPUCoreControl"},
   {name="CpuUnknown", namespace="2", identifier_type="s", identifier="[CookieLine]CPUCoreUnknown"},
   {name="CpuClass3", namespace="2", identifier_type="s", identifier="[CookieLine]CPUCoreCommClass3"},
   {name="CpuClass1", namespace="2", identifier_type="s", identifier="[CookieLine]CPUCoreCommClass1"},
   {name="CpuIdle", namespace="2", identifier_type="s", identifier="[CookieLine]CPUIdle"},
   {name="CpuControlMotion", namespace="2", identifier_type="s", identifier="[CookieLine]CPUCoreControlMotion"},
   {name="TaskAlarmEmulate", namespace="2", identifier_type="s", identifier="[CookieLine]TaskPercentage[1]"},
   {name="TaskMotion", namespace="2", identifier_type="s", identifier="[CookieLine]TaskPercentage[2]"},
   {name="TaskNew", namespace="2", identifier_type="s", identifier="[CookieLine]TaskPercentage[3]"},
  ]
  [[inputs.opcua.group]]
  name="Machines"
  namespace="2"
  identifier_type="s"
  tags=[["Part","Conditioner"]]
  nodes = [
   {name="ConditionerTemp1", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsConditioner.AAlarm1[1]",tags=[["Sensor","Temperature"]]},
   {name="ConditionerPH", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsConditioner.AAlarm1[2]",tags=[["Sensor","PH"]]},
   {name="ConditionerTemp2", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsConditioner.AAlarm1[3]",tags=[["Sensor","Temperature"]]},
   {name="ConditionerFlow", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsConditioner.AAlarm1[4]",tags=[["Sensor","Flow"]]},
  ]
  [[inputs.opcua.group]]
  name="Machines"
  namespace="2"
  identifier_type="s"
  tags=[["Part","Furnace"]]
  nodes = [
   {name="FuranceZone1Temp", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsFurance.AAlarm1[1]",tags=[["Sensor","Temperature"]]},
   {name="FuranceZone2Temp", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsFurance.AAlarm1[2]",tags=[["Sensor","Temperature"]]},
   {name="FuranceZone3Temp", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsFurance.AAlarm1[3]",tags=[["Sensor","Temperature"]]},
   {name="FuranceZone4Temp", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsFurance.AAlarm1[4]",tags=[["Sensor","Temperature"]]},
   {name="FurancePressure", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsFurance.AAlarm1[0]",tags=[["Sensor","Pressure"]]},
   ]
  [[inputs.opcua.group]]
  name="Machines"
  namespace="2"
  identifier_type="s"
  tags=[["Part","Picking"]]
  nodes = [
   {name="PickingTemp1", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsPicking.AAlarm1[1]",tags=[["Sensor","Temperature"]]},
   {name="PickingPH", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsPicking.AAlarm1[2]",tags=[["Sensor","PH"]]},
   {name="PickingTemp2", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsPicking.AAlarm1[3]",tags=[["Sensor","Temperature"]]},
   {name="PickingFlow", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsPicking.AAlarm1[4]",tags=[["Sensor","Flow"]]},
  ]
  [[inputs.opcua.group]]
  name="Machines"
  namespace="2"
  identifier_type="s"
  tags=[["Part","Rinsing"]]
  nodes = [
   {name="RinsingTemp1", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsRinsing.AAlarm1[1]",tags=[["Sensor","Temperature"]]},
   {name="RinsingTemp2", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsRinsing.AAlarm1[2]",tags=[["Sensor","Temperature"]]},
   {name="RinsingTemp3", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsRinsing.AAlarm1[3]",tags=[["Sensor","Temperature"]]},
   {name="RinsingPressure", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsRinsing.AAlarm1[4]",tags=[["Sensor","Pressure"]]},
   ]
  [[inputs.opcua.group]]
  name="Machines"
  namespace="2"
  identifier_type="s"
  tags=[["Part","Takeup"]]
  nodes = [
   {name="TakeUpP1Speed", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsTakeup.AAlarm1[1]",tags=[["Sensor","Speed"]]},
   {name="TakeUpP1Current", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsTakeup.AAlarm1[2]",tags=[["Sensor","Current"]]},
   {name="TakeUpP2Speed", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsTakeup.AAlarm1[3]",tags=[["Sensor","Speed"]]},
   {name="TakeUpP2Current", namespace="2", identifier_type="s", identifier="[CookieLine]Program:AlarmsTakeup.AAlarm1[4]",tags=[["Sensor","Current"]]},
  ]
    [[inputs.opcua.group]]
  name="Energy"
  namespace="2"
  identifier_type="s"
  nodes = [
   {name="PowerConsumption", namespace="2", identifier_type="s", identifier="[CookieLine]SimPowerConsumption"},
   {name="GasConsumption", namespace="2", identifier_type="s", identifier="[CookieLine]SimGasConsumption"},
  ]
    [[inputs.opcua.group]]
  name="TestTags"
  namespace="2"
  identifier_type="s"
  nodes = [
    {name="a_cos0012", identifier="[CookieLine]a_cos[0012]"},
    {name="a_cos0013", identifier="[CookieLine]a_cos[0013]"},
    {name="a_cos0014", identifier="[CookieLine]a_cos[0014]"},
    {name="a_cos0015", identifier="[CookieLine]a_cos[0015]"},
    {name="a_cos0016", identifier="[CookieLine]a_cos[0016]"},
    {name="a_cos0017", identifier="[CookieLine]a_cos[0017]"},
    {name="a_cos0018", identifier="[CookieLine]a_cos[0018]"},
    {name="a_cos0019", identifier="[CookieLine]a_cos[0019]"},
    {name="a_cos0020", identifier="[CookieLine]a_cos[0020]"},
    {name="a_cos0021", identifier="[CookieLine]a_cos[0021]"},
    {name="a_cos0022", identifier="[CookieLine]a_cos[0022]"},
    {name="a_cos0023", identifier="[CookieLine]a_cos[0023]"},
    {name="a_cos0024", identifier="[CookieLine]a_cos[0024]"},
    {name="a_cos0025", identifier="[CookieLine]a_cos[0025]"},
    {name="a_cos0026", identifier="[CookieLine]a_cos[0026]"},
    {name="a_cos0027", identifier="[CookieLine]a_cos[0027]"},
    {name="a_cos0028", identifier="[CookieLine]a_cos[0028]"},
    {name="a_cos0029", identifier="[CookieLine]a_cos[0029]"},
    {name="a_cos0030", identifier="[CookieLine]a_cos[0030]"},
    {name="a_cos0031", identifier="[CookieLine]a_cos[0031]"},
    {name="a_cos0032", identifier="[CookieLine]a_cos[0032]"},
    {name="a_cos0033", identifier="[CookieLine]a_cos[0033]"},
    {name="a_cos0034", identifier="[CookieLine]a_cos[0034]"},
    {name="a_cos0035", identifier="[CookieLine]a_cos[0035]"},
    {name="a_cos0036", identifier="[CookieLine]a_cos[0036]"},
    {name="a_cos0037", identifier="[CookieLine]a_cos[0037]"},
    {name="a_cos0038", identifier="[CookieLine]a_cos[0038]"},
    {name="a_cos0039", identifier="[CookieLine]a_cos[0039]"},
    {name="a_cos0040", identifier="[CookieLine]a_cos[0040]"},
    {name="a_cos0041", identifier="[CookieLine]a_cos[0041]"},
    {name="a_cos0042", identifier="[CookieLine]a_cos[0042]"},
    {name="a_cos0043", identifier="[CookieLine]a_cos[0043]"},
    {name="a_cos0044", identifier="[CookieLine]a_cos[0044]"},
    {name="a_cos0045", identifier="[CookieLine]a_cos[0045]"},
    {name="a_cos0046", identifier="[CookieLine]a_cos[0046]"},
    {name="a_cos0047", identifier="[CookieLine]a_cos[0047]"},
    {name="a_cos0048", identifier="[CookieLine]a_cos[0048]"},
    {name="a_cos0049", identifier="[CookieLine]a_cos[0049]"},
    {name="a_cos0050", identifier="[CookieLine]a_cos[0050]"},
    {name="a_cos0051", identifier="[CookieLine]a_cos[0051]"},
    {name="a_cos0052", identifier="[CookieLine]a_cos[0052]"},
    {name="a_cos0053", identifier="[CookieLine]a_cos[0053]"},
    {name="a_cos0054", identifier="[CookieLine]a_cos[0054]"},
    {name="a_cos0055", identifier="[CookieLine]a_cos[0055]"},
    {name="a_cos0056", identifier="[CookieLine]a_cos[0056]"},
    {name="a_cos0057", identifier="[CookieLine]a_cos[0057]"},
    {name="a_cos0058", identifier="[CookieLine]a_cos[0058]"},
    {name="a_cos0059", identifier="[CookieLine]a_cos[0059]"},
    {name="a_cos0060", identifier="[CookieLine]a_cos[0060]"},
    {name="a_cos0061", identifier="[CookieLine]a_cos[0061]"},
    {name="a_cos0062", identifier="[CookieLine]a_cos[0062]"},
    {name="a_cos0063", identifier="[CookieLine]a_cos[0063]"},
    {name="a_cos0064", identifier="[CookieLine]a_cos[0064]"},
    {name="a_cos0065", identifier="[CookieLine]a_cos[0065]"},
    {name="a_cos0066", identifier="[CookieLine]a_cos[0066]"},
    {name="a_cos0067", identifier="[CookieLine]a_cos[0067]"},
    {name="a_cos0068", identifier="[CookieLine]a_cos[0068]"},
    {name="a_cos0069", identifier="[CookieLine]a_cos[0069]"},
    {name="a_cos0070", identifier="[CookieLine]a_cos[0070]"},
    {name="a_cos0071", identifier="[CookieLine]a_cos[0071]"},
    {name="a_cos0072", identifier="[CookieLine]a_cos[0072]"},
    {name="a_cos0073", identifier="[CookieLine]a_cos[0073]"},
    {name="a_cos0074", identifier="[CookieLine]a_cos[0074]"},
    {name="a_cos0075", identifier="[CookieLine]a_cos[0075]"},
    {name="a_cos0076", identifier="[CookieLine]a_cos[0076]"},
    {name="a_cos0077", identifier="[CookieLine]a_cos[0077]"},
    {name="a_cos0078", identifier="[CookieLine]a_cos[0078]"},
    {name="a_cos0079", identifier="[CookieLine]a_cos[0079]"},
    {name="a_cos0080", identifier="[CookieLine]a_cos[0080]"},
    {name="a_cos0081", identifier="[CookieLine]a_cos[0081]"},
    {name="a_cos0082", identifier="[CookieLine]a_cos[0082]"},
    {name="a_cos0083", identifier="[CookieLine]a_cos[0083]"},
    {name="a_cos0084", identifier="[CookieLine]a_cos[0084]"},
    {name="a_cos0085", identifier="[CookieLine]a_cos[0085]"},
    {name="a_cos0086", identifier="[CookieLine]a_cos[0086]"},
    {name="a_cos0087", identifier="[CookieLine]a_cos[0087]"},
    {name="a_cos0088", identifier="[CookieLine]a_cos[0088]"},
    {name="a_cos0089", identifier="[CookieLine]a_cos[0089]"},
    {name="a_cos0090", identifier="[CookieLine]a_cos[0090]"},
    {name="a_cos0091", identifier="[CookieLine]a_cos[0091]"},
    {name="a_cos0092", identifier="[CookieLine]a_cos[0092]"},
    {name="a_cos0093", identifier="[CookieLine]a_cos[0093]"},
    {name="a_cos0094", identifier="[CookieLine]a_cos[0094]"},
    {name="a_cos0095", identifier="[CookieLine]a_cos[0095]"},
    {name="a_cos0096", identifier="[CookieLine]a_cos[0096]"},
    {name="a_cos0097", identifier="[CookieLine]a_cos[0097]"},
    {name="a_cos0098", identifier="[CookieLine]a_cos[0098]"},
    {name="a_cos0099", identifier="[CookieLine]a_cos[0099]"},
    {name="a_cos0100", identifier="[CookieLine]a_cos[0100]"},
    {name="a_cos0101", identifier="[CookieLine]a_cos[0101]"},
    {name="a_cos0102", identifier="[CookieLine]a_cos[0102]"},
    {name="a_cos0103", identifier="[CookieLine]a_cos[0103]"},
    {name="a_cos0104", identifier="[CookieLine]a_cos[0104]"},
    {name="a_cos0105", identifier="[CookieLine]a_cos[0105]"},
    {name="a_cos0106", identifier="[CookieLine]a_cos[0106]"},
    {name="a_cos0107", identifier="[CookieLine]a_cos[0107]"},
    {name="a_cos0108", identifier="[CookieLine]a_cos[0108]"},
    {name="a_cos0109", identifier="[CookieLine]a_cos[0109]"},
    {name="a_cos0110", identifier="[CookieLine]a_cos[0110]"},
    {name="a_cos0111", identifier="[CookieLine]a_cos[0111]"},
    {name="a_cos0112", identifier="[CookieLine]a_cos[0112]"},
    {name="a_cos0113", identifier="[CookieLine]a_cos[0113]"},
    {name="a_cos0114", identifier="[CookieLine]a_cos[0114]"},
    {name="a_cos0115", identifier="[CookieLine]a_cos[0115]"},
    {name="a_cos0116", identifier="[CookieLine]a_cos[0116]"},
    {name="a_cos0117", identifier="[CookieLine]a_cos[0117]"},
    {name="a_cos0118", identifier="[CookieLine]a_cos[0118]"},
    {name="a_cos0119", identifier="[CookieLine]a_cos[0119]"},
    {name="a_cos0120", identifier="[CookieLine]a_cos[0120]"},
    {name="a_cos0121", identifier="[CookieLine]a_cos[0121]"},
    {name="a_cos0122", identifier="[CookieLine]a_cos[0122]"},
    {name="a_cos0123", identifier="[CookieLine]a_cos[0123]"},
    {name="a_cos0124", identifier="[CookieLine]a_cos[0124]"},
    {name="a_cos0125", identifier="[CookieLine]a_cos[0125]"},
    {name="a_cos0126", identifier="[CookieLine]a_cos[0126]"},
    {name="a_cos0127", identifier="[CookieLine]a_cos[0127]"},
    {name="a_cos0128", identifier="[CookieLine]a_cos[0128]"},
    {name="a_cos0129", identifier="[CookieLine]a_cos[0129]"},
    {name="a_cos0130", identifier="[CookieLine]a_cos[0130]"},
    {name="a_cos0131", identifier="[CookieLine]a_cos[0131]"},
    {name="a_cos0132", identifier="[CookieLine]a_cos[0132]"},
    {name="a_cos0133", identifier="[CookieLine]a_cos[0133]"},
    {name="a_cos0134", identifier="[CookieLine]a_cos[0134]"},
    {name="a_cos0135", identifier="[CookieLine]a_cos[0135]"},
    {name="a_cos0136", identifier="[CookieLine]a_cos[0136]"},
    {name="a_cos0137", identifier="[CookieLine]a_cos[0137]"},
    {name="a_cos0138", identifier="[CookieLine]a_cos[0138]"},
    {name="a_cos0139", identifier="[CookieLine]a_cos[0139]"},
    {name="a_cos0140", identifier="[CookieLine]a_cos[0140]"},
    {name="a_cos0141", identifier="[CookieLine]a_cos[0141]"},
    {name="a_cos0142", identifier="[CookieLine]a_cos[0142]"},
    {name="a_cos0143", identifier="[CookieLine]a_cos[0143]"},
    {name="a_cos0144", identifier="[CookieLine]a_cos[0144]"},
    {name="a_cos0145", identifier="[CookieLine]a_cos[0145]"},
    {name="a_cos0146", identifier="[CookieLine]a_cos[0146]"},
    {name="a_cos0147", identifier="[CookieLine]a_cos[0147]"},
    {name="a_cos0148", identifier="[CookieLine]a_cos[0148]"},
    {name="a_cos0149", identifier="[CookieLine]a_cos[0149]"},
    {name="a_cos0150", identifier="[CookieLine]a_cos[0150]"},
    {name="a_cos0151", identifier="[CookieLine]a_cos[0151]"},
    {name="a_cos0152", identifier="[CookieLine]a_cos[0152]"},
    {name="a_cos0153", identifier="[CookieLine]a_cos[0153]"},
    {name="a_cos0154", identifier="[CookieLine]a_cos[0154]"},
    {name="a_cos0155", identifier="[CookieLine]a_cos[0155]"},
    {name="a_cos0156", identifier="[CookieLine]a_cos[0156]"},
    {name="a_cos0157", identifier="[CookieLine]a_cos[0157]"},
    {name="a_cos0158", identifier="[CookieLine]a_cos[0158]"},
    {name="a_cos0159", identifier="[CookieLine]a_cos[0159]"},
    {name="a_cos0160", identifier="[CookieLine]a_cos[0160]"},
    {name="a_cos0161", identifier="[CookieLine]a_cos[0161]"},
    {name="a_cos0162", identifier="[CookieLine]a_cos[0162]"},
    {name="a_cos0163", identifier="[CookieLine]a_cos[0163]"},
    {name="a_cos0164", identifier="[CookieLine]a_cos[0164]"},
    {name="a_cos0165", identifier="[CookieLine]a_cos[0165]"},
    {name="a_cos0166", identifier="[CookieLine]a_cos[0166]"},
    {name="a_cos0167", identifier="[CookieLine]a_cos[0167]"},
    {name="a_cos0168", identifier="[CookieLine]a_cos[0168]"},
    {name="a_cos0169", identifier="[CookieLine]a_cos[0169]"},
    {name="a_cos0170", identifier="[CookieLine]a_cos[0170]"},
    {name="a_cos0171", identifier="[CookieLine]a_cos[0171]"},
    {name="a_cos0172", identifier="[CookieLine]a_cos[0172]"},
    {name="a_cos0173", identifier="[CookieLine]a_cos[0173]"},
    {name="a_cos0174", identifier="[CookieLine]a_cos[0174]"},
    {name="a_cos0175", identifier="[CookieLine]a_cos[0175]"},
    {name="a_cos0176", identifier="[CookieLine]a_cos[0176]"},
    {name="a_cos0177", identifier="[CookieLine]a_cos[0177]"},
    {name="a_cos0178", identifier="[CookieLine]a_cos[0178]"},
    {name="a_cos0179", identifier="[CookieLine]a_cos[0179]"},
    {name="a_cos0180", identifier="[CookieLine]a_cos[0180]"},
    {name="a_cos0181", identifier="[CookieLine]a_cos[0181]"},
    {name="a_cos0182", identifier="[CookieLine]a_cos[0182]"},
    {name="a_cos0183", identifier="[CookieLine]a_cos[0183]"},
    {name="a_cos0184", identifier="[CookieLine]a_cos[0184]"},
    {name="a_cos0185", identifier="[CookieLine]a_cos[0185]"},
    {name="a_cos0186", identifier="[CookieLine]a_cos[0186]"},
    {name="a_cos0187", identifier="[CookieLine]a_cos[0187]"},
    {name="a_cos0188", identifier="[CookieLine]a_cos[0188]"},
    {name="a_cos0189", identifier="[CookieLine]a_cos[0189]"},
    {name="a_cos0190", identifier="[CookieLine]a_cos[0190]"},
    {name="a_cos0191", identifier="[CookieLine]a_cos[0191]"},
    {name="a_cos0192", identifier="[CookieLine]a_cos[0192]"},
    {name="a_cos0193", identifier="[CookieLine]a_cos[0193]"},
    {name="a_cos0194", identifier="[CookieLine]a_cos[0194]"},
    {name="a_cos0195", identifier="[CookieLine]a_cos[0195]"},
    {name="a_cos0196", identifier="[CookieLine]a_cos[0196]"},
    {name="a_cos0197", identifier="[CookieLine]a_cos[0197]"},
    {name="a_cos0198", identifier="[CookieLine]a_cos[0198]"},
    {name="a_cos0199", identifier="[CookieLine]a_cos[0199]"},
    {name="a_cos0200", identifier="[CookieLine]a_cos[0200]"},
    {name="a_cos0201", identifier="[CookieLine]a_cos[0201]"},
    {name="a_cos0202", identifier="[CookieLine]a_cos[0202]"},
    {name="a_cos0203", identifier="[CookieLine]a_cos[0203]"},
    {name="a_cos0204", identifier="[CookieLine]a_cos[0204]"},
    {name="a_cos0205", identifier="[CookieLine]a_cos[0205]"},
    {name="a_cos0206", identifier="[CookieLine]a_cos[0206]"},
    {name="a_cos0207", identifier="[CookieLine]a_cos[0207]"},
    {name="a_cos0208", identifier="[CookieLine]a_cos[0208]"},
    {name="a_cos0209", identifier="[CookieLine]a_cos[0209]"},
    {name="a_cos0210", identifier="[CookieLine]a_cos[0210]"},
    {name="a_cos0211", identifier="[CookieLine]a_cos[0211]"},
    {name="a_cos0212", identifier="[CookieLine]a_cos[0212]"},
    {name="a_cos0213", identifier="[CookieLine]a_cos[0213]"},
    {name="a_cos0214", identifier="[CookieLine]a_cos[0214]"},
    {name="a_cos0215", identifier="[CookieLine]a_cos[0215]"},
    {name="a_cos0216", identifier="[CookieLine]a_cos[0216]"},
    {name="a_cos0217", identifier="[CookieLine]a_cos[0217]"},
    {name="a_cos0218", identifier="[CookieLine]a_cos[0218]"},
    {name="a_cos0219", identifier="[CookieLine]a_cos[0219]"},
    {name="a_cos0220", identifier="[CookieLine]a_cos[0220]"},
    {name="a_cos0221", identifier="[CookieLine]a_cos[0221]"},
    {name="a_cos0222", identifier="[CookieLine]a_cos[0222]"},
    {name="a_cos0223", identifier="[CookieLine]a_cos[0223]"},
    {name="a_cos0224", identifier="[CookieLine]a_cos[0224]"},
    {name="a_cos0225", identifier="[CookieLine]a_cos[0225]"},
    {name="a_cos0226", identifier="[CookieLine]a_cos[0226]"},
    {name="a_cos0227", identifier="[CookieLine]a_cos[0227]"},
    {name="a_cos0228", identifier="[CookieLine]a_cos[0228]"},
    {name="a_cos0229", identifier="[CookieLine]a_cos[0229]"},
    {name="a_cos0230", identifier="[CookieLine]a_cos[0230]"},
    {name="a_cos0231", identifier="[CookieLine]a_cos[0231]"},
    {name="a_cos0232", identifier="[CookieLine]a_cos[0232]"},
    {name="a_cos0233", identifier="[CookieLine]a_cos[0233]"},
    {name="a_cos0234", identifier="[CookieLine]a_cos[0234]"},
    {name="a_cos0235", identifier="[CookieLine]a_cos[0235]"},
    {name="a_cos0236", identifier="[CookieLine]a_cos[0236]"},
    {name="a_cos0237", identifier="[CookieLine]a_cos[0237]"},
    {name="a_cos0238", identifier="[CookieLine]a_cos[0238]"},
    {name="a_cos0239", identifier="[CookieLine]a_cos[0239]"},
    {name="a_cos0240", identifier="[CookieLine]a_cos[0240]"},
    {name="a_cos0241", identifier="[CookieLine]a_cos[0241]"},
    {name="a_cos0242", identifier="[CookieLine]a_cos[0242]"},
    {name="a_cos0243", identifier="[CookieLine]a_cos[0243]"},
    {name="a_cos0244", identifier="[CookieLine]a_cos[0244]"},
    {name="a_cos0245", identifier="[CookieLine]a_cos[0245]"},
    {name="a_cos0246", identifier="[CookieLine]a_cos[0246]"},
    {name="a_cos0247", identifier="[CookieLine]a_cos[0247]"},
    {name="a_cos0248", identifier="[CookieLine]a_cos[0248]"},
    {name="a_cos0249", identifier="[CookieLine]a_cos[0249]"},
    {name="a_cos0250", identifier="[CookieLine]a_cos[0250]"},
    {name="a_cos0251", identifier="[CookieLine]a_cos[0251]"},
    {name="a_cos0252", identifier="[CookieLine]a_cos[0252]"},
    {name="a_cos0253", identifier="[CookieLine]a_cos[0253]"},
    {name="a_cos0254", identifier="[CookieLine]a_cos[0254]"},
    {name="a_cos0255", identifier="[CookieLine]a_cos[0255]"},
    {name="a_cos0256", identifier="[CookieLine]a_cos[0256]"},
    {name="a_cos0257", identifier="[CookieLine]a_cos[0257]"},
    {name="a_cos0258", identifier="[CookieLine]a_cos[0258]"},
    {name="a_cos0259", identifier="[CookieLine]a_cos[0259]"},
    {name="a_cos0260", identifier="[CookieLine]a_cos[0260]"},
    {name="a_cos0261", identifier="[CookieLine]a_cos[0261]"},
    {name="a_cos0262", identifier="[CookieLine]a_cos[0262]"},
    {name="a_cos0263", identifier="[CookieLine]a_cos[0263]"},
    {name="a_cos0264", identifier="[CookieLine]a_cos[0264]"},
    {name="a_cos0265", identifier="[CookieLine]a_cos[0265]"},
    {name="a_cos0266", identifier="[CookieLine]a_cos[0266]"},
    {name="a_cos0267", identifier="[CookieLine]a_cos[0267]"},
    {name="a_cos0268", identifier="[CookieLine]a_cos[0268]"},
    {name="a_cos0269", identifier="[CookieLine]a_cos[0269]"},
    {name="a_cos0270", identifier="[CookieLine]a_cos[0270]"},
    {name="a_cos0271", identifier="[CookieLine]a_cos[0271]"},
    {name="a_cos0272", identifier="[CookieLine]a_cos[0272]"},
    {name="a_cos0273", identifier="[CookieLine]a_cos[0273]"},
    {name="a_cos0274", identifier="[CookieLine]a_cos[0274]"},
    {name="a_cos0275", identifier="[CookieLine]a_cos[0275]"},
    {name="a_cos0276", identifier="[CookieLine]a_cos[0276]"},
    {name="a_cos0277", identifier="[CookieLine]a_cos[0277]"},
    {name="a_cos0278", identifier="[CookieLine]a_cos[0278]"},
    {name="a_cos0279", identifier="[CookieLine]a_cos[0279]"},
    {name="a_cos0280", identifier="[CookieLine]a_cos[0280]"},
    {name="a_cos0281", identifier="[CookieLine]a_cos[0281]"},
    {name="a_cos0282", identifier="[CookieLine]a_cos[0282]"},
    {name="a_cos0283", identifier="[CookieLine]a_cos[0283]"},
    {name="a_cos0284", identifier="[CookieLine]a_cos[0284]"},
    {name="a_cos0285", identifier="[CookieLine]a_cos[0285]"},
    {name="a_cos0286", identifier="[CookieLine]a_cos[0286]"},
    {name="a_cos0287", identifier="[CookieLine]a_cos[0287]"},
    {name="a_cos0288", identifier="[CookieLine]a_cos[0288]"},
    {name="a_cos0289", identifier="[CookieLine]a_cos[0289]"},
    {name="a_cos0290", identifier="[CookieLine]a_cos[0290]"},
    {name="a_cos0291", identifier="[CookieLine]a_cos[0291]"},
    {name="a_cos0292", identifier="[CookieLine]a_cos[0292]"},
    {name="a_cos0293", identifier="[CookieLine]a_cos[0293]"},
    {name="a_cos0294", identifier="[CookieLine]a_cos[0294]"},
    {name="a_cos0295", identifier="[CookieLine]a_cos[0295]"},
    {name="a_cos0296", identifier="[CookieLine]a_cos[0296]"},
    {name="a_cos0297", identifier="[CookieLine]a_cos[0297]"},
    {name="a_cos0298", identifier="[CookieLine]a_cos[0298]"},
    {name="a_cos0299", identifier="[CookieLine]a_cos[0299]"},
    {name="a_cos0300", identifier="[CookieLine]a_cos[0300]"},
    {name="a_cos0301", identifier="[CookieLine]a_cos[0301]"},
    {name="a_cos0302", identifier="[CookieLine]a_cos[0302]"},
    {name="a_cos0303", identifier="[CookieLine]a_cos[0303]"},
    {name="a_cos0304", identifier="[CookieLine]a_cos[0304]"},
    {name="a_cos0305", identifier="[CookieLine]a_cos[0305]"},
    {name="a_cos0306", identifier="[CookieLine]a_cos[0306]"},
    {name="a_cos0307", identifier="[CookieLine]a_cos[0307]"},
    {name="a_cos0308", identifier="[CookieLine]a_cos[0308]"},
    {name="a_cos0309", identifier="[CookieLine]a_cos[0309]"},
    {name="a_cos0310", identifier="[CookieLine]a_cos[0310]"},
    {name="a_cos0311", identifier="[CookieLine]a_cos[0311]"},
    {name="a_cos0312", identifier="[CookieLine]a_cos[0312]"},
    {name="a_cos0313", identifier="[CookieLine]a_cos[0313]"},
    {name="a_cos0314", identifier="[CookieLine]a_cos[0314]"},
    {name="a_cos0315", identifier="[CookieLine]a_cos[0315]"},
    {name="a_cos0316", identifier="[CookieLine]a_cos[0316]"},
    {name="a_cos0317", identifier="[CookieLine]a_cos[0317]"},
    {name="a_cos0318", identifier="[CookieLine]a_cos[0318]"},
    {name="a_cos0319", identifier="[CookieLine]a_cos[0319]"},
    {name="a_cos0320", identifier="[CookieLine]a_cos[0320]"},
    {name="a_cos0321", identifier="[CookieLine]a_cos[0321]"},
    {name="a_cos0322", identifier="[CookieLine]a_cos[0322]"},
    {name="a_cos0323", identifier="[CookieLine]a_cos[0323]"},
    {name="a_cos0324", identifier="[CookieLine]a_cos[0324]"},
    {name="a_cos0325", identifier="[CookieLine]a_cos[0325]"},
    {name="a_cos0326", identifier="[CookieLine]a_cos[0326]"},
    {name="a_cos0327", identifier="[CookieLine]a_cos[0327]"},
    {name="a_cos0328", identifier="[CookieLine]a_cos[0328]"},
    {name="a_cos0329", identifier="[CookieLine]a_cos[0329]"},
    {name="a_cos0330", identifier="[CookieLine]a_cos[0330]"},
    {name="a_cos0331", identifier="[CookieLine]a_cos[0331]"},
    {name="a_cos0332", identifier="[CookieLine]a_cos[0332]"},
    {name="a_cos0333", identifier="[CookieLine]a_cos[0333]"},
    {name="a_cos0334", identifier="[CookieLine]a_cos[0334]"},
    {name="a_cos0335", identifier="[CookieLine]a_cos[0335]"},
    {name="a_cos0336", identifier="[CookieLine]a_cos[0336]"},
    {name="a_cos0337", identifier="[CookieLine]a_cos[0337]"},
    {name="a_cos0338", identifier="[CookieLine]a_cos[0338]"},
    {name="a_cos0339", identifier="[CookieLine]a_cos[0339]"},
    {name="a_cos0340", identifier="[CookieLine]a_cos[0340]"},
    {name="a_cos0341", identifier="[CookieLine]a_cos[0341]"},
    {name="a_cos0342", identifier="[CookieLine]a_cos[0342]"},
    {name="a_cos0343", identifier="[CookieLine]a_cos[0343]"},
    {name="a_cos0344", identifier="[CookieLine]a_cos[0344]"},
    {name="a_cos0345", identifier="[CookieLine]a_cos[0345]"},
    {name="a_cos0346", identifier="[CookieLine]a_cos[0346]"},
    {name="a_cos0347", identifier="[CookieLine]a_cos[0347]"},
    {name="a_cos0348", identifier="[CookieLine]a_cos[0348]"},
    {name="a_cos0349", identifier="[CookieLine]a_cos[0349]"},
    {name="a_cos0350", identifier="[CookieLine]a_cos[0350]"},
    {name="a_cos0351", identifier="[CookieLine]a_cos[0351]"},
    {name="a_cos0352", identifier="[CookieLine]a_cos[0352]"},
    {name="a_cos0353", identifier="[CookieLine]a_cos[0353]"},
    {name="a_cos0354", identifier="[CookieLine]a_cos[0354]"},
    {name="a_cos0355", identifier="[CookieLine]a_cos[0355]"},
    {name="a_cos0356", identifier="[CookieLine]a_cos[0356]"},
    {name="a_cos0357", identifier="[CookieLine]a_cos[0357]"},
    {name="a_cos0358", identifier="[CookieLine]a_cos[0358]"},
    {name="a_cos0359", identifier="[CookieLine]a_cos[0359]"},
    {name="a_cos0360", identifier="[CookieLine]a_cos[0360]"},
    {name="a_cos0361", identifier="[CookieLine]a_cos[0361]"},
    {name="a_cos0362", identifier="[CookieLine]a_cos[0362]"},
    {name="a_cos0363", identifier="[CookieLine]a_cos[0363]"},
    {name="a_cos0364", identifier="[CookieLine]a_cos[0364]"},
    {name="a_cos0365", identifier="[CookieLine]a_cos[0365]"},
    {name="a_cos0366", identifier="[CookieLine]a_cos[0366]"},
    {name="a_cos0367", identifier="[CookieLine]a_cos[0367]"},
    {name="a_cos0368", identifier="[CookieLine]a_cos[0368]"},
    {name="a_cos0369", identifier="[CookieLine]a_cos[0369]"},
    {name="a_cos0370", identifier="[CookieLine]a_cos[0370]"},
    {name="a_cos0371", identifier="[CookieLine]a_cos[0371]"},
    {name="a_cos0372", identifier="[CookieLine]a_cos[0372]"},
    {name="a_cos0373", identifier="[CookieLine]a_cos[0373]"},
    {name="a_cos0374", identifier="[CookieLine]a_cos[0374]"},
    {name="a_cos0375", identifier="[CookieLine]a_cos[0375]"},
    {name="a_cos0376", identifier="[CookieLine]a_cos[0376]"},
    {name="a_cos0377", identifier="[CookieLine]a_cos[0377]"},
    {name="a_cos0378", identifier="[CookieLine]a_cos[0378]"},
    {name="a_cos0379", identifier="[CookieLine]a_cos[0379]"},
    {name="a_cos0380", identifier="[CookieLine]a_cos[0380]"},
    {name="a_cos0381", identifier="[CookieLine]a_cos[0381]"},
    {name="a_cos0382", identifier="[CookieLine]a_cos[0382]"},
    {name="a_cos0383", identifier="[CookieLine]a_cos[0383]"},
    {name="a_cos0384", identifier="[CookieLine]a_cos[0384]"},
    {name="a_cos0385", identifier="[CookieLine]a_cos[0385]"},
    {name="a_cos0386", identifier="[CookieLine]a_cos[0386]"},
    {name="a_cos0387", identifier="[CookieLine]a_cos[0387]"},
    {name="a_cos0388", identifier="[CookieLine]a_cos[0388]"},
    {name="a_cos0389", identifier="[CookieLine]a_cos[0389]"},
    {name="a_cos0390", identifier="[CookieLine]a_cos[0390]"},
    {name="a_cos0391", identifier="[CookieLine]a_cos[0391]"},
    {name="a_cos0392", identifier="[CookieLine]a_cos[0392]"},
    {name="a_cos0393", identifier="[CookieLine]a_cos[0393]"},
    {name="a_cos0394", identifier="[CookieLine]a_cos[0394]"},
    {name="a_cos0395", identifier="[CookieLine]a_cos[0395]"},
    {name="a_cos0396", identifier="[CookieLine]a_cos[0396]"},
    {name="a_cos0397", identifier="[CookieLine]a_cos[0397]"},
    {name="a_cos0398", identifier="[CookieLine]a_cos[0398]"},
    {name="a_cos0399", identifier="[CookieLine]a_cos[0399]"},
    {name="a_cos0400", identifier="[CookieLine]a_cos[0400]"},
    {name="a_cos0401", identifier="[CookieLine]a_cos[0401]"},
    {name="a_cos0402", identifier="[CookieLine]a_cos[0402]"},
    {name="a_cos0403", identifier="[CookieLine]a_cos[0403]"},
    {name="a_cos0404", identifier="[CookieLine]a_cos[0404]"},
    {name="a_cos0405", identifier="[CookieLine]a_cos[0405]"},
    {name="a_cos0406", identifier="[CookieLine]a_cos[0406]"},
    {name="a_cos0407", identifier="[CookieLine]a_cos[0407]"},
    {name="a_cos0408", identifier="[CookieLine]a_cos[0408]"},
    {name="a_cos0409", identifier="[CookieLine]a_cos[0409]"},
    {name="a_cos0410", identifier="[CookieLine]a_cos[0410]"},
    {name="a_cos0411", identifier="[CookieLine]a_cos[0411]"},
    {name="a_cos0412", identifier="[CookieLine]a_cos[0412]"},
    {name="a_cos0413", identifier="[CookieLine]a_cos[0413]"},
    {name="a_cos0414", identifier="[CookieLine]a_cos[0414]"},
    {name="a_cos0415", identifier="[CookieLine]a_cos[0415]"},
    {name="a_cos0416", identifier="[CookieLine]a_cos[0416]"},
    {name="a_cos0417", identifier="[CookieLine]a_cos[0417]"},
    {name="a_cos0418", identifier="[CookieLine]a_cos[0418]"},
    {name="a_cos0419", identifier="[CookieLine]a_cos[0419]"},
    {name="a_cos0420", identifier="[CookieLine]a_cos[0420]"},
    {name="a_cos0421", identifier="[CookieLine]a_cos[0421]"},
    {name="a_cos0422", identifier="[CookieLine]a_cos[0422]"},
    {name="a_cos0423", identifier="[CookieLine]a_cos[0423]"},
    {name="a_cos0424", identifier="[CookieLine]a_cos[0424]"},
    {name="a_cos0425", identifier="[CookieLine]a_cos[0425]"},
    {name="a_cos0426", identifier="[CookieLine]a_cos[0426]"},
    {name="a_cos0427", identifier="[CookieLine]a_cos[0427]"},
    {name="a_cos0428", identifier="[CookieLine]a_cos[0428]"},
    {name="a_cos0429", identifier="[CookieLine]a_cos[0429]"},
    {name="a_cos0430", identifier="[CookieLine]a_cos[0430]"},
    {name="a_cos0431", identifier="[CookieLine]a_cos[0431]"},
    {name="a_cos0432", identifier="[CookieLine]a_cos[0432]"},
    {name="a_cos0433", identifier="[CookieLine]a_cos[0433]"},
    {name="a_cos0434", identifier="[CookieLine]a_cos[0434]"},
    {name="a_cos0435", identifier="[CookieLine]a_cos[0435]"},
    {name="a_cos0436", identifier="[CookieLine]a_cos[0436]"},
    {name="a_cos0437", identifier="[CookieLine]a_cos[0437]"},
    {name="a_cos0438", identifier="[CookieLine]a_cos[0438]"},
    {name="a_cos0439", identifier="[CookieLine]a_cos[0439]"},
    {name="a_cos0440", identifier="[CookieLine]a_cos[0440]"},
    {name="a_cos0441", identifier="[CookieLine]a_cos[0441]"},
    {name="a_cos0442", identifier="[CookieLine]a_cos[0442]"},
    {name="a_cos0443", identifier="[CookieLine]a_cos[0443]"},
    {name="a_cos0444", identifier="[CookieLine]a_cos[0444]"},
    {name="a_cos0445", identifier="[CookieLine]a_cos[0445]"},
    {name="a_cos0446", identifier="[CookieLine]a_cos[0446]"},
    {name="a_cos0447", identifier="[CookieLine]a_cos[0447]"},
    {name="a_cos0448", identifier="[CookieLine]a_cos[0448]"},
    {name="a_cos0449", identifier="[CookieLine]a_cos[0449]"},
    {name="a_cos0450", identifier="[CookieLine]a_cos[0450]"},
    {name="a_cos0451", identifier="[CookieLine]a_cos[0451]"},
    {name="a_cos0452", identifier="[CookieLine]a_cos[0452]"},
    {name="a_cos0453", identifier="[CookieLine]a_cos[0453]"},
    {name="a_cos0454", identifier="[CookieLine]a_cos[0454]"},
    {name="a_cos0455", identifier="[CookieLine]a_cos[0455]"},
    {name="a_cos0456", identifier="[CookieLine]a_cos[0456]"},
    {name="a_cos0457", identifier="[CookieLine]a_cos[0457]"},
    {name="a_cos0458", identifier="[CookieLine]a_cos[0458]"},
    {name="a_cos0459", identifier="[CookieLine]a_cos[0459]"},
    {name="a_cos0460", identifier="[CookieLine]a_cos[0460]"},
    {name="a_cos0461", identifier="[CookieLine]a_cos[0461]"},
    {name="a_cos0462", identifier="[CookieLine]a_cos[0462]"},
    {name="a_cos0463", identifier="[CookieLine]a_cos[0463]"},
    {name="a_cos0464", identifier="[CookieLine]a_cos[0464]"},
    {name="a_cos0465", identifier="[CookieLine]a_cos[0465]"},
    {name="a_cos0466", identifier="[CookieLine]a_cos[0466]"},
  ]